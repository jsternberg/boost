--- boost/python/suite/indexing/python_iterator.hpp
+++ boost/python/suite/indexing/python_iterator.hpp
@@ -0,0 +1,45 @@
+// -*- mode:c++ -*-
+//
+// Header file python_iterator.hpp
+//
+// Handy Python iterable iterators
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: python_iterator.hpp,v 1.1.2.5 2003/11/24 16:35:09 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_PYTHON_ITERATOR_HPP
+#define BOOST_PYTHON_INDEXING_PYTHON_ITERATOR_HPP
+
+#include <boost/python/object.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  struct BOOST_PYTHON_DECL python_iterator
+  {
+    python_iterator (boost::python::object);
+    // Sets a python type exception and calls throw_error_already_set if
+    // the passed object is not iterable via PyObject_GetIter
+
+    bool next ();
+    // Get the next item from the iterator, returning true for success
+
+    boost::python::object current() const;
+    // Callable only after a successful next()
+
+  private:
+    ::boost::python::object m_iter_obj;
+    ::boost::python::object m_next_method;
+    ::boost::python::object m_current;
+  };
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_PYTHON_ITERATOR_HPP
--- boost/python/suite/indexing/proxy_iterator.hpp	(revision 6923)
+++ boost/python/suite/indexing/proxy_iterator.hpp	(revision 6923)
@@ -0,0 +1,163 @@
+
+// Header file proxy_iterator.hpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/10/ 8   rmg     File creation
+//
+// $Id: proxy_iterator.hpp,v 1.1.2.8 2003/12/05 17:36:14 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_PROXY_ITERATOR_HPP
+#define BOOST_PYTHON_INDEXING_PROXY_ITERATOR_HPP
+
+#include <iterator>
+#include <boost/config.hpp>
+#include <boost/iterator.hpp>
+#include <boost/detail/workaround.hpp>
+
+namespace boost { namespace python { namespace indexing {
+
+  template <class ContainerProxy, typename ElementProxy, typename Traits,
+      typename Size, typename Iter>
+  class proxy_iterator
+    : public boost::iterator<
+          std::random_access_iterator_tag,
+          ElementProxy,
+          typename Traits::difference_type,
+          ElementProxy *,
+          ElementProxy // Already has reference semantics
+      >
+  {
+#if !defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    template<class C, class H, class G> friend class container_proxy;
+#endif
+
+    typedef boost::iterator<
+        std::random_access_iterator_tag,
+        ElementProxy,
+        typename Traits::difference_type,
+        ElementProxy *,
+        ElementProxy
+    > base_type;
+
+  public:
+    typedef ContainerProxy container_proxy_type;
+
+    typedef Iter raw_iterator;
+    typedef Traits raw_iterator_traits;
+    typedef Size size_type;
+    typedef typename base_type::value_type value_type;
+    typedef typename base_type::difference_type difference_type;
+
+    typedef value_type *pointer;
+    typedef value_type reference; // Already has reference semantics
+
+    proxy_iterator (container_proxy_type *p, size_type i)
+      : ptr (p), index (i)
+    {
+    }
+ 
+    proxy_iterator (container_proxy_type *p, raw_iterator iter)
+      : ptr (p), index (iter - p->raw_container().begin())
+    {
+    }
+
+    reference operator*() const { return ptr->at(index); }
+    pointer operator->() const { return &ptr->at(index); }
+    reference operator[](size_type s) { return ptr->at (index + s); }
+
+    proxy_iterator &operator++ () { ++index; return *this; }
+    proxy_iterator &operator+= (size_type s) { index += s; return *this; }
+
+    proxy_iterator &operator-- () { --index; return *this; }
+
+    proxy_iterator operator++ (int) {
+      proxy_iterator temp(*this);
+      ++index;
+      return temp;
+    }
+
+    proxy_iterator operator-- (int) {
+      proxy_iterator temp(*this);
+      --index;
+      return temp;
+    }
+
+    proxy_iterator &operator-= (size_type s) { index -= s; return *this; }
+
+    proxy_iterator operator+ (size_type s) const {
+      return proxy_iterator(*this) += s;
+    }
+
+    proxy_iterator operator- (size_type s) const {
+      return proxy_iterator(*this) -= s;
+    }
+
+    difference_type operator- (proxy_iterator i) const {
+      return index - i.index;
+    }
+
+    bool operator== (proxy_iterator const &other) const {
+      return (ptr == other.ptr) && (index == other.index);
+    }
+
+    bool operator!= (proxy_iterator const &other) const {
+      return !(*this == other);
+    }
+
+    bool operator< (proxy_iterator const &other) const {
+      return index < other.index;
+    }
+
+    bool operator<= (proxy_iterator const &other) const {
+      return index <= other.index;
+    }
+
+    bool operator> (proxy_iterator const &other) const {
+      return index > other.index;
+    }
+
+    bool operator>= (proxy_iterator const &other) const {
+      return index >= other.index;
+    }
+
+    void iter_swap (proxy_iterator const &other) const {
+      ptr->swap_elements (index, other.index);
+    }
+
+    //  public:
+    // Extensions to the normal iterator interface
+    //    void replace (value_type const &copy) { ptr->replace (index, copy); }
+
+#if defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    // Can't declare container_proxy as friend, so make data public
+  public:
+#else
+  private:
+#endif
+    container_proxy_type *ptr;
+    size_type index;
+  };
+} } }
+
+#if !BOOST_WORKAROUND (BOOST_MSVC, == 1300)
+// MSVC7.0 can't decide between this and the unspecialized version
+namespace std {
+  template <class C, typename E, typename T, typename S, typename I>
+  void iter_swap(
+      boost::python::indexing::proxy_iterator<C, E, T, S, I> const &first,
+      boost::python::indexing::proxy_iterator<C, E, T, S, I> const &second)
+  {
+    first.iter_swap (second);
+  }
+}
+#endif
+
+#endif // BOOST_PYTHON_INDEXING_PROXY_ITERATOR_HPP
--- boost/python/suite/indexing/element_proxy.hpp	(revision 6923)
+++ boost/python/suite/indexing/element_proxy.hpp	(revision 6923)
@@ -0,0 +1,187 @@
+// Header file element_proxy.hpp
+//
+// Proxy objects for invidivual elements in a container wrapped by
+// container_proxy
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/15   rmg     File creation from container_proxy.hpp
+//
+// $Id: element_proxy.hpp,v 1.1.2.10 2003/12/03 12:18:51 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ELEMENT_PROXY_HPP
+#define BOOST_PYTHON_INDEXING_ELEMENT_PROXY_HPP
+
+#include <boost/python/suite/indexing/shared_proxy_impl.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/get_pointer.hpp>
+#include <boost/utility/addressof.hpp>
+#include <boost/detail/workaround.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  template<typename ContainerProxy>
+  class element_proxy
+  {
+  public:
+    typedef typename ContainerProxy::shared_proxy proxy_type;
+    typedef typename ContainerProxy::raw_value_type raw_value_type;
+    typedef typename ContainerProxy::size_type size_type;
+    typedef boost::shared_ptr<proxy_type> proxy_pointer;
+
+    typedef typename proxy_type::value_type value_type;
+    typedef typename proxy_type::reference reference;
+    typedef typename proxy_type::pointer pointer;
+    typedef typename proxy_type::iterator_category iterator_category;
+    typedef typename proxy_type::difference_type difference_type;
+
+    typedef value_type element_type;      // Alias for register_ptr_to_python
+
+    element_proxy () : m_ptr () { }
+    explicit element_proxy (proxy_type *ptr) : m_ptr (ptr) { }
+    explicit element_proxy (proxy_pointer const &ptr) : m_ptr (ptr) { }
+
+    explicit element_proxy (raw_value_type const &val)
+      : m_ptr (new proxy_type(val))
+    {
+      // Create new standalone value (i.e. detached)
+    }
+
+    reference operator* () const { return m_ptr->operator*(); }
+    pointer operator-> () const { return (*m_ptr).operator->(); }
+    pointer get () const { return operator->(); }  // Alias for pointer_holder
+
+    // Implicit conversion to raw_value_type
+    operator reference () const { return operator*(); }
+
+#if BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+    // The implicit conversion doesn't work on MSVC6, so help it along
+    // a little.
+    bool operator== (value_type const &val) const { return (**this) == val; }
+    bool operator!= (value_type const &val) const { return (**this) != val; }
+    bool operator< (value_type const &val) const { return (**this) < val; }
+    bool operator> (value_type const &val) const { return (**this) > val; }
+#endif
+
+    element_proxy &operator= (value_type const &copy)
+    {
+      proxy_type &proxy = *m_ptr;
+      ContainerProxy *container = proxy.owner();
+      size_type index = proxy.index();
+
+      if (container)
+        {
+          container->replace (index, copy);
+          // Proxy was attached before, but is now detached. Make sure
+          // we now refer to the new element, instead of the detached
+          // copy of the old element
+          m_ptr = container->at (index).m_ptr;
+
+          // Note: in the special case that this we and the container
+          // proxy itself have the only references to the
+          // shared_proxy_impl, it is not necessary to first detach
+          // the proxy. Maybe best to implement when changing to
+          // intrusive_ptr instead of shared_ptr.
+        }
+
+      else
+        {
+          *proxy = copy;
+        }
+
+      return *this;
+    }
+
+    element_proxy &operator= (element_proxy const &copy)
+    {
+      // Required to make sorting a container_proxy work
+      return (*this) = *copy;
+    }
+
+    size_t use_count() const { return m_ptr.use_count(); } // For debugging
+
+  private:
+    proxy_pointer m_ptr;
+  };
+
+  template<typename ContainerProxy>
+  class const_element_proxy
+  {
+  public:
+    typedef element_proxy<ContainerProxy> base_type;
+    typedef typename base_type::proxy_type proxy_type;
+    typedef typename base_type::proxy_pointer proxy_pointer;
+    typedef typename base_type::raw_value_type raw_value_type;
+
+    typedef typename proxy_type::value_type const value_type;
+    typedef value_type &reference;
+    typedef value_type *pointer;
+    typedef typename base_type::iterator_category iterator_category;
+    typedef typename base_type::difference_type difference_type;
+
+    const_element_proxy () : m_base () { }
+    explicit const_element_proxy (proxy_type *ptr) : m_base (ptr) { }
+
+    explicit const_element_proxy (proxy_pointer const &ptr) : m_base (ptr) {}
+
+    const_element_proxy (const_element_proxy<ContainerProxy> const &copy)
+      : m_base (copy.m_base)
+    {
+    }
+
+    const_element_proxy (element_proxy<ContainerProxy> const &copy)
+      : m_base (copy)
+    {
+    }
+
+    explicit const_element_proxy (raw_value_type const &val)
+      : m_base (new proxy_type(val))
+    {
+    }
+
+    reference operator* () const { return *m_base; }
+    pointer operator-> () const { return m_base.operator->(); }
+
+    // Implicit conversion to raw_value_type const &
+    operator reference () const { return *m_base; }
+
+#if BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+    // The implicit conversion doesn't work on MSVC6, so help it along
+    // a little.
+    bool operator== (value_type const &val) const { return m_base == val; }
+    bool operator!= (value_type const &val) const { return m_base != val; }
+    bool operator< (value_type const &val) const { return m_base < val; }
+    bool operator> (value_type const &val) const { return m_base > val; }
+#endif
+
+    size_t use_count() const { return m_base.use_count(); } // For debugging
+
+  private:
+    base_type m_base;
+  };
+
+#ifdef BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+}} // namespace python::indexing
+#endif 
+
+  template<typename ContainerProxy>
+  typename ContainerProxy::raw_value_type *
+  get_pointer (python::indexing::element_proxy<ContainerProxy> const &proxy)
+  {
+    return ::boost::addressof (*proxy);
+  }
+
+#ifndef BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+    // Don't hide these other get_pointer overloads
+    using boost::get_pointer;
+}} // namespace python::indexing
+#endif 
+}
+
+#endif // BOOST_PYTHON_INDEXING_ELEMENT_PROXY_HPP
--- boost/python/suite/indexing/pair.hpp	(revision 6923)
+++ boost/python/suite/indexing/pair.hpp	(revision 6923)
@@ -0,0 +1,98 @@
+// Header file pair.hpp
+//
+// Exposes std::pair< key, value > class
+//
+// Copyright (c) 2007 Roman Yakovenko  
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2007/2/11   rmg     File creation
+//
+
+#ifndef BOOST_PYTHON_STD_PAIR_KEY_VALUE_11_02_2007_HPP
+#define BOOST_PYTHON_STD_PAIR_KEY_VALUE_11_02_2007_HPP
+
+#include <boost/config.hpp>
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <boost/detail/workaround.hpp>
+
+namespace boost { namespace python { namespace indexing { namespace mapping{
+
+namespace details{
+    
+template< typename TValueType, typename TValueCallPolicies >
+struct pair_exposer_t{
+
+    typedef TValueType pair_type;   
+    typedef BOOST_DEDUCED_TYPENAME pair_type::first_type key_type;
+    typedef BOOST_DEDUCED_TYPENAME pair_type::second_type mapped_type;
+    typedef pair_exposer_t< TValueType, TValueCallPolicies > exposer_type;
+    
+    pair_exposer_t(const std::string& name){
+        class_< pair_type >( name.c_str() )
+            .def( "__len__", &exposer_type::len )
+            .def( "__getitem__", &exposer_type::get_item )
+            .add_property( "key", &exposer_type::get_key )
+            .add_property( "value", &exposer_type::get_mapped );
+    }
+    
+private:
+
+    static size_t len( const pair_type& ){
+        return 2;
+    }
+
+    static object get_item( pair_type& p, size_t index ){
+        switch( index ){
+            case 0:{
+                return get_key( p );
+            }
+            case 1:{
+                return get_mapped( p );
+            }
+            case 2:{
+                objects::stop_iteration_error();
+                return object(); //will not reach this line
+            }
+            default:{
+                PyErr_SetString( PyExc_IndexError, "the only valid index numbers are: 0 and 1");
+                throw_error_already_set();
+                return object(); //will not reach this line
+            }
+        }
+    }
+    
+    static object get_key( const pair_type& p ){
+        return object( p.first );
+    }
+    
+    static object get_mapped( pair_type& p ){
+        typedef BOOST_DEDUCED_TYPENAME TValueCallPolicies::result_converter rc_type;
+        typedef BOOST_DEDUCED_TYPENAME rc_type:: template apply< mapped_type >::type converter_type;
+        converter_type converter;
+        return object( handle<>( converter( p.second ) ) );
+    }
+    
+};
+} //details
+    
+template< typename TPythonClass, typename TValueType, typename TValueCallPolicies >
+inline void register_value_type(TPythonClass &pyClass){ 
+    typedef details::pair_exposer_t< TValueType, TValueCallPolicies > exposer_type;
+    
+    object class_name(pyClass.attr("__name__"));
+    extract<std::string> class_name_extractor(class_name);
+    std::string pair_name = class_name_extractor() + "_entry";
+    
+    exposer_type expose( pair_name );
+}
+    
+} } } }
+
+#endif // BOOST_PYTHON_STD_PAIR_KEY_VALUE_11_02_2007_HPP
--- boost/python/suite/indexing/slice_handler.hpp	(revision 6923)
+++ boost/python/suite/indexing/slice_handler.hpp	(revision 6923)
@@ -0,0 +1,297 @@
+// -*- mode:c++ -*-
+//
+// Header file slice_handler.hpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/ 9   rmg     File creation
+//
+// $Id: slice_handler.hpp,v 1.1.2.10 2003/11/24 16:35:52 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SLICE_HANDLER_HPP
+#define BOOST_PYTHON_INDEXING_SLICE_HANDLER_HPP
+
+#include <boost/python/handle.hpp>
+#include <boost/python/object.hpp>
+#include <boost/python/list.hpp>
+#include <boost/python/extract.hpp>
+#include <boost/python/make_function.hpp>
+#include <boost/mpl/apply.hpp>
+#include <algorithm>
+
+#include <boost/python/suite/indexing/slice.hpp>
+#include <boost/python/suite/indexing/python_iterator.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  template<class Algorithms, class Policy>
+  struct slice_handler
+  {
+    static boost::python::object make_getitem (Policy const &);
+    static boost::python::object make_setitem (Policy const &);
+    static boost::python::object make_delitem (Policy const &);
+    static boost::python::object make_extend  (Policy const &);
+
+  private:
+    typedef typename Algorithms::container container;
+    typedef typename Algorithms::reference reference;
+    typedef typename Algorithms::slice_helper slice_helper;
+
+    static boost::python::list get_slice (container &, slice);
+    static void set_slice (container &, slice, boost::python::object);
+    static void del_slice (container &, slice);
+    static void extend (container &, boost::python::object);
+  };
+
+  namespace detail {
+    template<typename Policy>
+    struct postcall_override
+    {
+      // This class overrides the Policy's postcall function and
+      // result_conveter to handle the list returned from get_slice.
+      // The Policy's result_converter is removed, since it gets
+      // applied within get_slice. Our postcall override applies the
+      // original postcall to each element of the Python list returned
+      // from get_slice.
+
+      typedef boost::python::default_result_converter result_converter;
+      typedef typename Policy::argument_package argument_package;
+
+      postcall_override (Policy const &p);
+
+      bool precall (PyObject *args);
+      PyObject* postcall (PyObject *args, PyObject *result);
+
+    private:
+      Policy m_base;
+    };
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements the slice version of __getitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  boost::python::object
+  slice_handler<Algorithms, Policy>
+  ::make_getitem (Policy const &policy)
+  {
+    return
+      boost::python::make_function(
+          get_slice, detail::postcall_override<Policy> (policy));
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements the slice version of __setitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  boost::python::object
+  slice_handler<Algorithms, Policy>
+  ::make_setitem (Policy const &policy)
+  {
+    // should we try to get funky with policy::precall?
+    return boost::python::make_function (set_slice, policy);
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements the slice version of __delitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  boost::python::object
+  slice_handler<Algorithms, Policy>
+  ::make_delitem (Policy const &policy)
+  {
+    // should we try to get funky with policy::precall?
+    return boost::python::make_function (del_slice, policy);
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements extend
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  boost::python::object
+  slice_handler<Algorithms, Policy>
+  ::make_extend (Policy const &policy)
+  {
+    // should we try to get funky with policy::precall?
+    return boost::python::make_function (extend, policy);
+  }
+
+  namespace detail {
+    ////////////////////////////////////////////////////////////////////////
+    // postcall_override constructor
+    ////////////////////////////////////////////////////////////////////////
+
+    template<class Policy>
+    postcall_override<Policy>::postcall_override (Policy const &p)
+      : m_base (p)
+    {
+    }
+
+    ////////////////////////////////////////////////////////////////////////
+    // precall forwarder
+    ////////////////////////////////////////////////////////////////////////
+
+    template<class Policy>
+    bool postcall_override<Policy>::precall (PyObject *args)
+    {
+      return m_base.precall (args);
+    }
+
+    ////////////////////////////////////////////////////////////////////////
+    // Apply base postcall to each element of the list returend by get_slice
+    ////////////////////////////////////////////////////////////////////////
+
+    template<class Policy>
+    PyObject *
+    postcall_override<Policy>::postcall (PyObject *args, PyObject *result)
+    {
+      int size = PyList_Size (result);
+
+      for (int count = 0; count < size; ++count)
+        {
+          m_base.postcall (args, PyList_GetItem (result, count));
+        }
+
+      return result;
+    }
+  } // namespace detail
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation for the slice version of __getitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  boost::python::list
+  slice_handler<Algorithms, Policy>
+  ::get_slice (container &c, slice sl)
+  {
+    typedef typename Policy::result_converter converter_type;
+    typedef typename Algorithms::reference reference;
+
+    typename boost::mpl::apply1<converter_type, reference>::type
+      converter;
+
+    boost::python::list result;
+
+    slice_helper helper (Algorithms::make_slice_helper (c, sl));
+
+    while (helper.next())
+      {
+        // Apply the result converter (only) to each element before
+        // appending. postcall is done in postcall_override
+
+        result.append (boost::python::handle<> (converter (helper.current())));
+      }
+
+    return result;
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation for the slice version of __setitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  void
+  slice_handler<Algorithms, Policy>
+  ::set_slice (container &c, slice sl, boost::python::object values)
+  {
+    python_iterator value_iter (values);
+
+    // Try two kinds of extractors - the first is more efficient (using
+    // a reference to existing object, if possible and sensible) and the
+    // second allowing implicit conversions.
+
+    typedef boost::python::extract<
+        BOOST_DEDUCED_TYPENAME Algorithms::value_param> extractor1;
+
+    typedef boost::python::extract<
+        BOOST_DEDUCED_TYPENAME Algorithms::value_type> extractor2;
+
+    // Note: any error during this operation will probably leave the
+    // container partially updated. This can occur (for example) if the
+    // replacement sequence is of a different length to the original
+    // slice and the container does not support insertion/deletion.
+    // This could be prevented if the length of the replacement sequence
+    // is known in advance (via __len__, for example) but not otherwise.
+
+    slice_helper write_helper (Algorithms::make_slice_helper (c, sl));
+
+    // Overwrite and/or insert elements
+    while (value_iter.next())
+      {
+        extractor1 ex1 (value_iter.current());
+
+        if (ex1.check())
+          {
+            write_helper.write (ex1);
+          }
+
+        else
+          {
+            write_helper.write (extractor2 (value_iter.current()));
+          }
+      }
+
+    if (write_helper.next())
+      {
+        // We've run out of elements to read, but write_helper is not
+        // finished. Erase the remaining element(s) in the slice
+        write_helper.erase_remaining();
+      }
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation for the slice version of __delitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  void
+  slice_handler<Algorithms, Policy>
+  ::del_slice (container &c, slice sl)
+  {
+    slice_helper helper (Algorithms::make_slice_helper (c, sl));
+
+    if (helper.next())
+      {
+        helper.erase_remaining();
+      }
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation of extend
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy>
+  void
+  slice_handler<Algorithms, Policy>
+  ::extend (container &c, boost::python::object values)
+  {
+    // Set up a slice at the tail end of the container, and use
+    // set_slice to do all the hard work.
+
+    boost::python::object length
+      ((boost::python::handle<>
+        (PyInt_FromLong (Algorithms::size (c)))));
+
+    slice sl
+      ((boost::python::handle<>
+        (PySlice_New
+         (length.ptr(),
+          boost::python::object().ptr(),
+          boost::python::object().ptr()))));
+
+    set_slice (c, sl, values);
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SLICE_HANDLER_HPP
--- boost/python/suite/indexing/vector.hpp	(revision 6923)
+++ boost/python/suite/indexing/vector.hpp	(revision 6923)
@@ -0,0 +1,60 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file vector.hpp
+//
+// Indexing algorithms support for std::vector instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: vector.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_VECTOR_HPP
+#define BOOST_PYTHON_INDEXING_VECTOR_HPP
+
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <vector>
+
+namespace boost { namespace python { namespace indexing {
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::vector instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class T, class Allocator>
+    class algorithms_selector<std::vector<T, Allocator> >
+    {
+      typedef std::vector<T, Allocator> Container;
+
+      typedef random_access_sequence_traits<Container>       mutable_traits;
+      typedef random_access_sequence_traits<Container const> const_traits;
+
+    public:
+      typedef default_algorithms<mutable_traits> mutable_algorithms;
+      typedef default_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = random_access_sequence_traits<Container>
+  >
+  struct vector_suite
+    : container_suite<Container, MethodMask, default_algorithms<Traits> >
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_VECTOR_HPP
--- boost/python/suite/indexing/value_traits.hpp	(revision 6923)
+++ boost/python/suite/indexing/value_traits.hpp	(revision 6923)
@@ -0,0 +1,84 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file value_traits.hpp:
+//
+// Traits information for use in determining which Python methods to
+// support for a container with elements of a given type.
+//
+// History
+// =======
+// 2003/ 9/12   rmg     File creation
+//
+// $Id: value_traits.hpp,v 1.1.2.6 2003/12/05 17:36:12 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_VALUE_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_VALUE_TRAITS_HPP
+
+#include <boost/config.hpp>
+#include <boost/shared_ptr.hpp>
+#include <functional>
+
+namespace boost { namespace python { namespace indexing {
+  // The default_value_traits template is used by all ContainerTraits
+  // templates. It can be overridden by specialization or by supplying
+  // the optional ValueTraits parameter to a container traits
+  // template.
+  template<typename T> struct value_traits;
+
+  // Implementation for default use. Providing this in a separate
+  // template allows specializations of value_traits to make use of
+  // it.
+  template<typename T>
+  struct simple_value_traits {
+    BOOST_STATIC_CONSTANT (bool, equality_comparable = true);
+    typedef std::equal_to<T> equal_to;
+
+    BOOST_STATIC_CONSTANT (bool, less_than_comparable = true);
+    typedef std::less<T> less;
+
+    // Default, do-nothing, version of visit_container_class
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class (PythonClass &, Policy const &) { }
+  };
+
+  // Implementation using pointer indirection
+  template <typename Ptr>
+  struct indirect_value_traits : simple_value_traits<Ptr> {
+    // Hide the base class versions of the comparisons, using these
+    // indirect versions
+    struct less : std::binary_function<Ptr, Ptr, bool> {
+      bool operator() (Ptr const &p1, Ptr const &p2) const {
+        return *p1 < *p2;
+      }
+    };
+
+    struct equal_to : std::binary_function<Ptr, Ptr, bool> {
+      bool operator() (Ptr const &p1, Ptr const &p2) const {
+        return *p1 == *p2;
+      }
+    };
+  };
+
+  // Default implementation selection. It's basically just a typedef
+  // for simple_value_traits
+  template<typename T>
+  struct value_traits : simple_value_traits<T>
+  {
+  };
+
+#if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  // Partial specialization for instances of boost::shared_ptr
+  template<typename T>
+  struct value_traits< ::boost::shared_ptr<T> >
+    : indirect_value_traits< ::boost::shared_ptr<T> >
+  {
+  };
+#endif
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_VALUE_TRAITS_HPP
--- boost/python/suite/indexing/methods.hpp	(revision 6923)
+++ boost/python/suite/indexing/methods.hpp	(revision 6923)
@@ -0,0 +1,113 @@
+// Copyright (c) 2004 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file methods.hpp
+//
+// Methods (and sets of methods) that containers can provide.
+//
+// History
+// =======
+// 2004/ 1/11   rmg     File creation
+//
+// $Id: methods.hpp,v 1.1.2.1 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_METHODS_HPP
+#define BOOST_PYTHON_INDEXING_METHODS_HPP
+
+#include <boost/config.hpp>
+#include <boost/mpl/if.hpp>
+
+namespace boost { namespace python { namespace indexing {
+
+  typedef unsigned long method_set_type;
+
+  enum methods_enum {
+    method_len            = 1UL <<  0,
+    method_iter           = 1UL <<  1,
+    method_getitem        = 1UL <<  2,
+    method_getitem_slice  = 1UL <<  3,
+    method_index          = 1UL <<  4,
+    method_contains       = 1UL <<  5,
+    method_count          = 1UL <<  6,
+    method_has_key        = 1UL <<  7,
+    method_setitem        = 1UL <<  8,
+    method_setitem_slice  = 1UL <<  9,
+    method_delitem        = 1UL << 10,
+    method_delitem_slice  = 1UL << 11,
+    method_reverse        = 1UL << 12,
+    method_append         = 1UL << 13,
+    method_insert         = 1UL << 14,
+    method_extend         = 1UL << 15,
+    method_sort           = 1UL << 16
+  };
+
+  // Some sets of methods that could be useful for disabling expensive
+  // features. e.g. something & ~(slice_methods | search_methods)
+
+  enum {
+    slice_methods
+      = method_getitem_slice | method_setitem_slice | method_delitem_slice
+  };
+
+  enum {
+    search_methods
+      = method_index | method_contains | method_count | method_has_key
+  };
+
+  enum {
+    reorder_methods
+      = method_sort | method_reverse
+  };
+
+  enum {
+    insert_methods
+      = method_append | method_insert | method_extend
+  };
+
+  enum {
+    all_methods = ~0UL
+  };
+
+  namespace detail {
+    // Compile-time constant selection:
+    //
+    // method_set_if<c, t, f>::value == (c ? t : f)
+    //
+    // where c is convertible to bool, and t and f are convertible to
+    // method_set_type. This gives a compile-time constant reliably on
+    // all supported compilers.
+
+    template<
+        bool Cond, method_set_type TrueValue, method_set_type FalseValue = 0>
+
+    struct method_set_if {
+      struct true_type {
+        BOOST_STATIC_CONSTANT(method_set_type, value = TrueValue);
+      };
+
+      struct false_type {
+        BOOST_STATIC_CONSTANT(method_set_type, value = FalseValue);
+      };
+
+      typedef typename mpl::if_c<Cond, true_type, false_type>::type
+          result_type;
+
+      BOOST_STATIC_CONSTANT(method_set_type, value = result_type::value);
+    };
+
+    // Compile-time set membership test:
+    // is_member<set, mem>::value == (bool) set & mem
+    template<method_set_type Set, method_set_type Member>
+    struct is_member {
+      // Use a cast to prevent MSVC truncation warning C4305
+      BOOST_STATIC_CONSTANT (bool, value = (bool) (Set & Member));
+    };
+  }
+
+} } } // boost::python::indexing
+
+#endif // BOOST_PYTHON_INDEXING_METHODS_HPP
--- boost/python/suite/indexing/deque.hpp	(revision 6923)
+++ boost/python/suite/indexing/deque.hpp	(revision 6923)
@@ -0,0 +1,60 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file deque.hpp
+//
+// Indexing algorithms support for std::deque instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: deque.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_DEQUE_HPP
+#define BOOST_PYTHON_INDEXING_DEQUE_HPP
+
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <deque>
+
+namespace boost { namespace python { namespace indexing {
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::deque instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class T, class Allocator>
+    class algorithms_selector<std::deque<T, Allocator> >
+    {
+      typedef std::deque<T, Allocator> Container;
+
+      typedef random_access_sequence_traits<Container>       mutable_traits;
+      typedef random_access_sequence_traits<Container const> const_traits;
+
+    public:
+      typedef default_algorithms<mutable_traits> mutable_algorithms;
+      typedef default_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = random_access_sequence_traits<Container>
+  >
+  struct deque_suite
+    : container_suite<Container, MethodMask, default_algorithms<Traits> >
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_DEQUE_HPP
--- boost/python/suite/indexing/container_traits.hpp	(revision 6923)
+++ boost/python/suite/indexing/container_traits.hpp	(revision 6923)
@@ -0,0 +1,159 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file container_traits.hpp
+//
+// Traits information about entire containers for use in determining
+// what Python methods to provide.
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation as container_suite.hpp
+// 2003/ 9/ 8   rmg     Renamed container_traits.hpp
+// 2003/10/28   rmg     Split container-specific versions into separate headers
+// 2004/ 1/28   rmg     Convert to bitset-based feature selection
+//
+// $Id: container_traits.hpp,v 1.1.2.15 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_CONTAINER_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_CONTAINER_TRAITS_HPP
+
+#include <boost/python/suite/indexing/suite_utils.hpp>
+#include <boost/python/suite/indexing/methods.hpp>
+#include <boost/python/suite/indexing/value_traits.hpp>
+
+#include <boost/type_traits.hpp>
+#include <boost/call_traits.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/type_traits/ice.hpp>
+#include <boost/iterator/iterator_traits.hpp>
+
+namespace boost { namespace python { namespace indexing {
+#if BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+  // MSVC6 has problems with get_signature if parameter types have
+  // top-level const qualification (e.g. int const). Unfortunately,
+  // this is exactly what happens with boost::call_traits, so we
+  // substitute a really dumb version of it instead.
+
+  template<typename T> struct broken_call_traits {
+    typedef T const & param_type;
+  };
+# define BOOST_PYTHON_INDEXING_CALL_TRAITS broken_call_traits
+#else
+# define BOOST_PYTHON_INDEXING_CALL_TRAITS ::boost::call_traits
+#endif
+
+  /////////////////////////////////////////////////////////////////////////
+  // Lowest common denominator traits - applicable to real containers
+  // and iterator pairs
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container, typename ValueTraits = detail::no_override>
+  struct base_container_traits
+  {
+    typedef base_container_traits<Container, ValueTraits> self_type;
+
+  protected:
+    BOOST_STATIC_CONSTANT(
+        bool, is_mutable = ! boost::is_const<Container>::value);
+
+  public:
+    typedef Container container;
+
+    typedef BOOST_DEDUCED_TYPENAME container::value_type value_type;
+
+    typedef BOOST_DEDUCED_TYPENAME mpl::if_<
+        is_const<container>,
+        BOOST_DEDUCED_TYPENAME container::const_iterator,
+        BOOST_DEDUCED_TYPENAME container::iterator
+      >::type iterator;
+
+    typedef typename ::boost::iterator_reference<iterator>::type reference;
+
+    typedef value_type key_type; // Used for find, etc.
+    typedef typename container::size_type size_type;
+    typedef typename make_signed<size_type>::type index_type;
+    // at(), operator[]. Signed to support Python -ve indexes
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS<value_type>::param_type
+        value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS<key_type>::param_type
+        key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS<index_type>::param_type
+        index_param;
+
+    // Allow client code to replace the default value traits via our
+    // second (optional) template parameter
+    typedef value_traits<value_type> default_value_traits;
+    typedef typename detail::maybe_override<
+        default_value_traits, ValueTraits>::type value_traits_type;
+
+    // Forward visit_container_class to value_traits_type
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class(
+        PythonClass &pyClass, Policy const &policy)
+    {
+      value_traits_type::visit_container_class (pyClass, policy);
+    }
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits for sequences with random access - std::vector,
+  // std::deque and the like
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container, typename ValueTraits = detail::no_override>
+  class random_access_sequence_traits
+    : public base_container_traits<Container, ValueTraits>
+  {
+    typedef base_container_traits<Container, ValueTraits> base_class;
+
+  public:
+    typedef typename base_class::value_traits_type value_traits_type;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_len
+            | method_getitem
+            | method_getitem_slice
+
+            | detail::method_set_if<
+                  value_traits_type::equality_comparable,
+                    method_index
+                  | method_contains
+                  | method_count
+              >::value
+
+            | detail::method_set_if<
+                  base_class::is_mutable,
+                    method_setitem
+                  | method_setitem_slice
+                  | method_delitem
+                  | method_delitem_slice
+                  | method_reverse
+                  | method_append
+                  | method_insert
+                  | method_extend
+              >::value
+
+            | detail::method_set_if<
+                  type_traits::ice_and<
+                      base_class::is_mutable,
+                      value_traits_type::less_than_comparable
+                  >::value,
+                  method_sort
+              >::value
+
+        ));
+
+        // Not supported: method_iter, method_has_key
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP
--- boost/python/suite/indexing/algorithms.hpp	(revision 6923)
+++ boost/python/suite/indexing/algorithms.hpp	(revision 6923)
@@ -0,0 +1,563 @@
+// Header file algorithms.hpp
+//
+// Uniform interface layer for all containers.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/11   rmg     File creation from suite_utils.hpp
+// 2003/10/28   rmg     Split container-specific versions into separate headers
+// 2006/10/25   Roman   Adding keys function to assoc_algorithms class
+//
+// $Id: algorithms.hpp,v 1.1.2.15 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ALGORITHMS_HPP
+#define BOOST_PYTHON_INDEXING_ALGORITHMS_HPP
+
+#include <boost/python/suite/indexing/suite_utils.hpp>
+
+#include <boost/type_traits.hpp>
+#include <boost/python/errors.hpp>
+#include <boost/python/suite/indexing/int_slice_helper.hpp>
+#include <boost/python/suite/indexing/slice.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/limits.hpp>
+#include <algorithm>
+#include <functional>
+#include <stdexcept>
+#include <string>
+#include <set>
+
+namespace boost { namespace python { namespace indexing {
+  template<typename ContainerTraits, typename Ovr = detail::no_override>
+  class default_algorithms
+  {
+    typedef default_algorithms<ContainerTraits, Ovr> self_type;
+    typedef typename detail::maybe_override<self_type, Ovr>
+        ::type most_derived;
+
+  public:
+    typedef ContainerTraits container_traits;
+
+    // Import typedefs from the container_traits for convenience
+    typedef typename ContainerTraits::container   container;
+    typedef typename ContainerTraits::iterator    iterator;
+    typedef typename ContainerTraits::reference   reference;
+    typedef typename ContainerTraits::size_type   size_type;
+    typedef typename ContainerTraits::value_type  value_type;
+    typedef typename ContainerTraits::value_param value_param;
+    typedef typename ContainerTraits::index_param index_param;
+    typedef typename ContainerTraits::key_param   key_param;
+
+    // Defer selection of supported_methods to the ContainerTraits
+    // template argument. This makes sense because default_algorithms
+    // derives all of its other information from this argument, and
+    // can't decide which of the static member functions will
+    // instantiate successfully for the container. Obviously a
+    // custom-written Algorithms implementation could choose to
+    // provide the supported_methods directly.
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = ContainerTraits::supported_methods);
+
+    static size_type size       (container &);
+    static iterator  find       (container &, key_param);
+    static size_type get_index  (container &, key_param);
+    static size_type count      (container &, key_param);
+    static bool      contains   (container &, key_param);
+    static void      reverse    (container &);
+    static reference get        (container &, index_param);
+    static void      assign     (container &, index_param, value_param);
+    static void      insert     (container &, index_param, value_param);
+    static void      erase_one  (container &, index_param);
+    static void      erase_range(container &, index_param, index_param);
+    static void      push_back  (container &, value_param);
+    static void      sort       (container &);
+    //    static void      sort       (container &, PyObject *);
+
+    static iterator  begin      (container &c) { return c.begin(); }
+    static iterator  end        (container &c) { return c.end(); }
+
+    // Reasonable defaults for slice handling
+    typedef int_slice_helper<self_type, integer_slice> slice_helper;
+
+    static slice_helper make_slice_helper (container &c, slice const &);
+
+    // Default visit_container_class
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class(
+        PythonClass &pyClass, Policy const &policy)
+    {
+      container_traits::visit_container_class (pyClass, policy);
+    }
+
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+    // MSVC6 and 7.0 seem to complain about most_derived::bounds_check
+    // for an instantiation of list_algorithms.
+  public:
+#else
+  private:
+#endif
+    static size_type bounds_check(
+        container &, index_param, char const *msg,
+        bool one_past = false,
+        bool truncate = false);
+    // Throws std::out_of_range if necessary. If one_past is set, then
+    // indexes up to container.size() *inclusive* are allowed. If
+    // truncate is set, then out of bounds values are reset to the
+    // nearest in-bound value (and if none exists, throws an
+    // exception). If truncate is *not* set, then negative values index
+    // from the upper bound backwards and are bounds-checked.
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Base class for associative containers
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr = detail::no_override>
+  class assoc_algorithms
+    : public default_algorithms
+        <ContainerTraits,
+        BOOST_DEDUCED_TYPENAME detail::maybe_override
+            <assoc_algorithms<ContainerTraits, Ovr>, Ovr>
+          ::type>
+  {
+    typedef assoc_algorithms<ContainerTraits, Ovr> self_type;
+    typedef typename detail::maybe_override<self_type, Ovr>
+        ::type most_derived;
+    typedef default_algorithms<ContainerTraits, most_derived> Parent;
+
+  public:
+    typedef typename Parent::iterator iterator;
+    typedef typename Parent::size_type size_type;
+    typedef typename Parent::container container;
+    typedef typename Parent::reference reference;
+    typedef typename Parent::key_param key_param;
+    typedef typename Parent::value_param value_param;
+    typedef typename Parent::index_param index_param;
+
+    static reference get        (container &, index_param);
+
+    // Use member functions for the following (hiding base class versions)
+    static void      erase_one (container &, key_param);
+    static iterator  find      (container &, key_param);
+    static size_type count     (container &, key_param);
+    static bool      contains  (container &, key_param);
+
+    // Default visit_container_class
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class( PythonClass &pyClass, Policy const &policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+    }
+
+  
+  protected:
+    static iterator  find_or_throw (container &, index_param);
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Get the size of a container
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::size_type
+  default_algorithms<ContainerTraits, Ovr>::size (container &c)
+  {
+    return c.size();
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Range check an index and throw out_of_range if necessary
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::size_type
+  default_algorithms<ContainerTraits, Ovr>::bounds_check(
+      container &c,
+      index_param ix,
+      char const *msg,
+      bool one_past,
+      bool truncate)
+  {
+    size_type bound = most_derived::size(c) + (one_past ? 1 : 0);
+    size_type result;
+
+    if (truncate)
+      {
+        if (ix < 0)
+          {
+            result = 0;
+          }
+
+        else
+          {
+            result = ix;
+
+            if ((result >= bound) && (bound > 0))
+              {
+                result = bound - 1;
+              }
+          }
+      }
+
+    else if (ix < 0)
+      {
+        if (size_type(-ix) > bound)
+          {
+            throw std::out_of_range (msg);
+          }
+  
+        result = bound + ix;
+      }
+
+    else
+      {
+        result = ix;
+      }
+
+    if (result >= bound)
+      {
+        throw std::out_of_range (msg);
+      }
+
+    return result;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::iterator
+  default_algorithms<ContainerTraits, Ovr>::find(
+      container &c, key_param key)
+  {
+    typedef typename container_traits::value_traits_type vtraits;
+    typedef typename vtraits::equal_to comparison;
+
+    return std::find_if(
+        most_derived::begin(c),
+        most_derived::end(c),
+        std::bind1st (comparison(), key));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element and return its index (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::size_type
+  default_algorithms<ContainerTraits, Ovr>::get_index(
+      container &c, key_param key)
+  {
+    iterator found (most_derived::find (c, key));
+
+    if (found == most_derived::end(c))
+      {
+        PyErr_SetString(
+            PyExc_ValueError, "get_index: element not found");
+
+        boost::python::throw_error_already_set ();
+      }
+
+    iterator start (most_derived::begin (c));
+    return std::distance (start, found);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Count occurances of an element in a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::size_type
+  default_algorithms<ContainerTraits, Ovr>::count(
+      container &c, key_param key)
+  {
+    typedef typename container_traits::value_traits_type vtraits;
+    typedef typename vtraits::equal_to comparison;
+
+    return std::count_if(
+        most_derived::begin(c),
+        most_derived::end(c),
+        std::bind1st (comparison(), key));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Check whether a container contains the given element (std algo ver)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  bool
+  default_algorithms<ContainerTraits, Ovr>::contains(
+      container &c, key_param key)
+  {
+    return most_derived::find (c, key) != most_derived::end(c);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::reference
+  default_algorithms<ContainerTraits, Ovr>::get(
+      container &c, index_param ix)
+  {
+    return c[most_derived::bounds_check (c, ix, "get")];
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Assign a value at a particular index (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  default_algorithms<ContainerTraits, Ovr>::assign(
+      container &c, index_param ix, value_param val)
+  {
+    c[most_derived::bounds_check (c, ix, "assign")] = val;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert at end of a container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  default_algorithms<ContainerTraits, Ovr>::push_back(
+      container &c, value_param v)
+  {
+    c.push_back (v);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert at an index in the container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  default_algorithms<ContainerTraits, Ovr>::insert(
+      container &c, index_param i, value_param v)
+  {
+    iterator insert_pos (most_derived::begin(c));
+
+    // Index may range up to c.size() inclusive to allow inserting at end
+    std::advance(
+        insert_pos, most_derived::bounds_check (c, i, "insert", true, true));
+
+    c.insert (insert_pos, v);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Erase between given indexes in the container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  default_algorithms<ContainerTraits, Ovr>::erase_range(
+      container &c, index_param from, index_param to)
+  {
+    iterator start (most_derived::begin(c));
+    iterator finish (most_derived::begin(c));
+
+    // Start index must be properly in bounds
+    std::advance
+      (start, most_derived::bounds_check (c, from, "erase_range (from)"));
+
+    // End index is one-past-the-end, so may range up to c.size() inclusive
+    std::advance
+      (finish, most_derived::bounds_check (c, to, "erase_range (to)", true));
+
+    c.erase (start, finish);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Erase one element at the given index in the container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  default_algorithms<ContainerTraits, Ovr>::erase_one(
+      container &c, index_param ix)
+  {
+    iterator iter (most_derived::begin(c));
+    std::advance (iter, most_derived::bounds_check (c, ix, "erase_one"));
+    c.erase (iter);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Reverse the contents of a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void default_algorithms<ContainerTraits, Ovr>::reverse (container &c)
+  {
+    std::reverse (most_derived::begin(c), most_derived::end(c));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Sort the contents of a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void default_algorithms<ContainerTraits, Ovr>::sort (container &c)
+  {
+    typedef typename container_traits::value_traits_type vtraits;
+    typedef typename vtraits::less comparison;
+    std::sort (most_derived::begin(c), most_derived::end(c), comparison());
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // slice_helper factory function (default version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME default_algorithms<ContainerTraits, Ovr>::slice_helper
+  default_algorithms<ContainerTraits, Ovr>
+  ::make_slice_helper (container &c, slice const &sl)
+  {
+    return slice_helper (c, integer_slice (sl, most_derived::size (c)));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (associative version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME assoc_algorithms<ContainerTraits, Ovr>::reference
+  assoc_algorithms<ContainerTraits, Ovr>::get (container &c, index_param ix)
+  {
+    return *most_derived::find_or_throw (c, ix);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Erase elements with the given key (associative version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  assoc_algorithms<ContainerTraits, Ovr>::erase_one(
+      container &c, key_param key)
+  {
+    if (c.erase (key) == 0)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, "Container does not hold value to be erased");
+
+        boost::python::throw_error_already_set ();
+      }
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in an associative container
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME assoc_algorithms<ContainerTraits, Ovr>::iterator
+  assoc_algorithms<ContainerTraits, Ovr>
+  ::find (container &c, key_param key)
+  {
+    return c.find (key);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in an associative container
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  bool
+  assoc_algorithms<ContainerTraits, Ovr>::contains(
+      container &c, key_param key)
+  {
+    return most_derived::find (c, key) != most_derived::end(c);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in an associative container - throw an exception if
+  // not found
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME assoc_algorithms<ContainerTraits, Ovr>::iterator
+  assoc_algorithms<ContainerTraits, Ovr>::find_or_throw(
+      container &c, index_param ix)
+  {
+    iterator iter = most_derived::find (c, ix);
+
+    if (iter == most_derived::end(c))
+      {
+        PyErr_SetString(
+            PyExc_ValueError, "associative container: key not found");
+
+        boost::python::throw_error_already_set ();
+      }
+
+    return iter;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Count occurances of an element in a container (associative version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME assoc_algorithms<ContainerTraits, Ovr>::size_type
+  assoc_algorithms<ContainerTraits, Ovr>::count(
+      container &c, key_param key)
+  {
+    return c.count (key);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Some meta-information to select algorithms for const and
+  // non-const qualified containers. All algorithms_selector specializations
+  // include two publically accessible typedefs, called
+  // mutable_algorithms and const_algorithms.  This saves having to
+  // have separate partial specializations of algorithms for
+  // const and non-const containers. Client code should probably
+  // specialize algorithms directly.
+  /////////////////////////////////////////////////////////////////////////
+
+  namespace detail {
+    template<typename Container> class algorithms_selector
+# if defined(BOOST_MPL_MSVC_ETI_BUG)
+    {
+      // Bogus types to prevent compile errors due to ETI
+      typedef algorithms_selector<Container> mutable_algorithms;
+      typedef algorithms_selector<Container> const_algorithms;
+    }
+# endif
+    ;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms selection for mutable containers
+  /////////////////////////////////////////////////////////////////////////
+
+  template<class Container>
+  struct algorithms
+    : public detail::algorithms_selector<Container>::mutable_algorithms
+  {
+  };
+
+# if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms selection for const-qualified containers
+  /////////////////////////////////////////////////////////////////////////
+
+  template<class Container>
+  struct algorithms<Container const>
+    : public detail::algorithms_selector<Container>::const_algorithms
+  {
+  };
+# endif
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ALGORITHMS_HPP
--- boost/python/suite/indexing/list.hpp	(revision 6923)
+++ boost/python/suite/indexing/list.hpp	(revision 6923)
@@ -0,0 +1,167 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file list.hpp
+//
+// Indexing algorithms support for std::list instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: list.hpp,v 1.1.2.7 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_LIST_HPP
+#define BOOST_PYTHON_INDEXING_LIST_HPP
+
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <list>
+
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+# include <boost/static_assert.hpp>
+# include <boost/type_traits.hpp>
+#endif
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::list instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container, typename ValueTraits = detail::no_override>
+  class list_traits
+    : public base_container_traits<Container, ValueTraits>
+  {
+    typedef base_container_traits<Container, ValueTraits> base_class;
+
+  public:
+    typedef typename base_class::value_traits_type value_traits_type;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_len
+            | method_iter
+
+            | detail::method_set_if<
+                  value_traits_type::equality_comparable,
+                    method_contains
+                  | method_count
+              >::value
+
+            | detail::method_set_if<
+                  base_class::is_mutable,
+                  method_reverse
+                  | method_append
+              >::value
+
+            | detail::method_set_if<
+                  type_traits::ice_and<
+                      base_class::is_mutable,
+                      value_traits_type::less_than_comparable
+                  >::value,
+                  method_sort
+              >::value
+
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::list instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr = detail::no_override>
+  class list_algorithms
+    : public default_algorithms
+        <ContainerTraits,
+        typename detail::maybe_override
+            <list_algorithms<ContainerTraits, Ovr>, Ovr>
+          ::type>
+  {
+    typedef list_algorithms<ContainerTraits, Ovr> self_type;
+    typedef typename detail::maybe_override<self_type, Ovr>::type most_derived;
+    typedef default_algorithms<ContainerTraits, most_derived> Parent;
+
+  public:
+    typedef typename Parent::container container;
+
+    // Use member functions for the following (hiding base class versions)
+    static void      reverse    (container &);
+    static void      sort       (container &);
+    //    static void      sort       (container &, PyObject *);
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::list instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class T, class Allocator>
+    class algorithms_selector<std::list<T, Allocator> >
+    {
+      typedef std::list<T, Allocator> Container;
+
+      typedef list_traits<Container>       mutable_traits;
+      typedef list_traits<Container const> const_traits;
+
+    public:
+      typedef list_algorithms<mutable_traits> mutable_algorithms;
+      typedef list_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = list_traits<Container>
+  >
+  struct list_suite
+    : container_suite<Container, MethodMask, list_algorithms<Traits> >
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Reverse the contents of a list (using member function)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void list_algorithms<ContainerTraits, Ovr>::reverse (container &c)
+  {
+    c.reverse();
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Sort the contents of a list (using member function)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void list_algorithms<ContainerTraits, Ovr>::sort (container &c)
+  {
+    typedef typename self_type::container_traits::value_traits_type
+      vtraits;
+
+    typedef typename vtraits::less comparison;
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+    // MSVC6 doesn't have a templated sort member in list, so we just
+    // use the parameterless version. This gives the correct behaviour
+    // provided that value_traits_type::less is exactly
+    // std::less<value_type>. It would be possible to support
+    // std::greater<T> (the only other overload of list::sort in
+    // MSVC6) with some additional work.
+    BOOST_STATIC_ASSERT(
+        (::boost::is_same<comparison, std::less<value_type> >::value));
+    c.sort ();
+#else
+    c.sort (comparison());
+#endif
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_LIST_HPP
--- boost/python/suite/indexing/map.hpp	(revision 6923)
+++ boost/python/suite/indexing/map.hpp	(revision 6923)
@@ -0,0 +1,238 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file map.hpp
+//
+// Indexing algorithms support for std::map instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: map.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_MAP_HPP
+#define BOOST_PYTHON_INDEXING_MAP_HPP
+
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <boost/detail/workaround.hpp>
+#include <map>
+#include <boost/python/suite/indexing/pair.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::map instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container>
+  class map_traits : public base_container_traits<Container>
+  {
+    typedef base_container_traits<Container> base_class;
+
+  public:
+# if BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+    // MSVC6 has a nonstandard name for mapped_type in std::map
+    typedef typename Container::referent_type value_type;
+# else
+    typedef typename Container::mapped_type value_type;
+# endif
+    typedef value_type &                    reference;
+    typedef typename Container::key_type    index_type; // operator[]
+    typedef typename Container::key_type    key_type;   // find, count, ...
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <value_type>::param_type
+      value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <key_type>::param_type
+      key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <index_type>::param_type
+      index_param;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_iter
+
+            | method_getitem
+            | method_contains
+            | method_count
+            | method_has_key
+
+            | detail::method_set_if<
+                  base_class::is_mutable,
+                    method_setitem
+                  | method_delitem
+                  | method_insert
+              >::value
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::map instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr = detail::no_override>
+  class map_algorithms
+    : public assoc_algorithms
+        <ContainerTraits,
+        typename detail::maybe_override
+            <map_algorithms<ContainerTraits, Ovr>, Ovr>
+          ::type>
+  {
+    typedef map_algorithms<ContainerTraits, Ovr> self_type;
+    typedef typename detail::maybe_override<self_type, Ovr>::type most_derived;
+    typedef assoc_algorithms<ContainerTraits, most_derived> Parent;
+
+  public:
+    typedef typename Parent::container container;
+    typedef typename Parent::reference reference;
+    typedef typename Parent::index_param index_param;
+    typedef typename Parent::value_param value_param;
+
+    static reference get (container &, index_param);
+    // Version to return only the mapped type
+
+    static boost::python::list keys( container & );
+  
+    static void      assign     (container &, index_param, value_param);
+    static void      insert     (container &, index_param, value_param);
+  
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class( PythonClass &pyClass, Policy const &policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+      pyClass.def( "keys", &self_type::keys );     
+        
+      typedef BOOST_DEDUCED_TYPENAME most_derived::container::value_type value_type;
+      mapping::register_value_type< PythonClass, value_type, Policy >( pyClass );
+      //now we can expose iterators functionality
+      pyClass.def( "__iter__", python::iterator< BOOST_DEDUCED_TYPENAME most_derived::container >() );
+    }  
+  
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::map instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class Key, class T, class Compare, class Allocator>
+    class algorithms_selector<std::map<Key, T, Compare, Allocator> >
+    {
+      typedef std::map<Key, T, Compare, Allocator> Container;
+
+      typedef map_traits<Container>       mutable_traits;
+      typedef map_traits<Container const> const_traits;
+
+    public:
+      typedef map_algorithms<mutable_traits> mutable_algorithms;
+      typedef map_algorithms<const_traits>   const_algorithms;
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::multimap instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class Key, class T, class Compare, class Allocator>
+    class algorithms_selector<std::multimap<Key, T, Compare, Allocator> >
+    {
+      typedef std::multimap<Key, T, Compare, Allocator> Container;
+
+      typedef map_traits<Container>       mutable_traits;
+      typedef map_traits<Container const> const_traits;
+
+    public:
+      typedef map_algorithms<mutable_traits> mutable_algorithms;
+      typedef map_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = map_traits<Container>
+  >
+  struct map_suite
+    : container_suite<Container, MethodMask, map_algorithms<Traits> >
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (map version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  BOOST_DEDUCED_TYPENAME map_algorithms<ContainerTraits, Ovr>::reference
+  map_algorithms<ContainerTraits, Ovr>::get (container &c, index_param ix)
+  {
+    return most_derived::find_or_throw (c, ix)->second;
+  }
+
+  
+  template<typename ContainerTraits, typename Ovr>
+  boost::python::list
+  map_algorithms<ContainerTraits, Ovr>::keys( container &c )
+  {
+    boost::python::list _keys;
+    //For some reason code with set could not be compiled
+    //std::set< key_param > unique_keys;
+    typedef BOOST_DEDUCED_TYPENAME container::iterator iter_type;
+    for( iter_type index = most_derived::begin(c); index != most_derived::end(c); ++index ){
+        //if( unique_keys.end() == unique_keys.find( index->first ) ){
+        //    unique_keys.insert( index->first );
+        if( !_keys.count( index->first ) ){
+            _keys.append( index->first );
+        }
+        //}
+    }
+        
+    return _keys;
+  }
+  
+  /////////////////////////////////////////////////////////////////////////
+  // Assign a value at a particular index (map version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  map_algorithms<ContainerTraits, Ovr>::assign(
+      container &c, index_param ix, value_param val)
+  {
+    c[ix] = val;   // Handles overwrite and insert
+  }
+
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert a new key, value pair into a map
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  map_algorithms<ContainerTraits, Ovr>::insert(
+      container &c, index_param ix, value_param val)
+  {
+    typedef std::pair
+      <BOOST_DEDUCED_TYPENAME self_type::container_traits::index_type,
+      BOOST_DEDUCED_TYPENAME self_type::container_traits::value_type>
+      pair_type;
+
+    // Can't use std::make_pair, because param types may be references
+
+    if (!c.insert (pair_type (ix, val)).second)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, "Map already holds value for insertion");
+
+        boost::python::throw_error_already_set ();
+      }
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_MAP_HPP
--- boost/python/suite/indexing/container_proxy.hpp	(revision 6923)
+++ boost/python/suite/indexing/container_proxy.hpp	(revision 6923)
@@ -0,0 +1,737 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file container_proxy.hpp
+//
+// A container-wrapper that provides Python-style reference semantics
+// for values stored in vector-like containers via element proxies.
+//
+// Class invariant:
+//   size() == m_proxies.size()
+//   for 0 <= i < size()
+//     m_proxies[i].get() != 0
+//     m_proxies[i]->owner() == this
+//     m_proxies[i]->index() == i
+//     m_proxies[i]->m_element_ptr.get() == 0
+//
+// History
+// =======
+// 2003/ 8/26   rmg     File creation
+// 2003/10/23   rmg     Change pointer container from map to sequence
+//
+// $Id: container_proxy.hpp,v 1.1.2.28 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_CONTAINER_PROXY_HPP
+#define BOOST_PYTHON_INDEXING_CONTAINER_PROXY_HPP
+
+#include <boost/python/suite/indexing/proxy_iterator.hpp>
+#include <boost/python/suite/indexing/shared_proxy_impl.hpp>
+#include <boost/python/suite/indexing/element_proxy.hpp>
+#include <boost/python/suite/indexing/element_proxy_traits.hpp>
+#include <boost/python/suite/indexing/workaround.hpp>
+#include <boost/python/suite/indexing/methods.hpp>
+
+#include <vector>
+#include <cassert>
+#include <boost/shared_ptr.hpp>
+#include <boost/mpl/apply.hpp>
+#include <boost/iterator/iterator_traits.hpp>
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+
+namespace boost { namespace python { namespace indexing {
+
+  template<typename T> struct identity {
+    typedef T held_type;
+
+    static T &       get(T &       obj) { return obj; }
+    static T const & get(T const & obj) { return obj; }
+
+    static T    create ()                     { return T(); }
+    static T    copy   (T const &copy)        { return copy; }
+    static void assign (T &to, T const &from) { to = from; }
+    static void pre_destruction (T &)         { }
+    static void swap   (T &one, T &two)       { std::swap (one, two); }
+  };
+
+  template<typename P> struct deref {
+    typedef P held_type;
+
+    typedef typename boost::iterator_value<P>::type     value;
+
+    static value &       get (P &       ptr)  { return *ptr; }
+    static value const & get (P const & ptr)  { return *ptr; }
+
+    static P    create ()                     { return P(); }
+    static P    copy   (P const &copy)        { return copy; }
+    static void assign (P &to, P const &from) { to = from; }
+    static void pre_destruction (P &)         { }
+    static void swap   (P &one, P &two)       { std::swap (one, two); }
+  };
+
+  struct vector_generator {
+    // Generates vector type for any element type with default allocator
+    template<typename Element> struct apply {
+      typedef std::vector<Element> type;
+    };
+  };
+
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+  // Early template instantiation (ETI) workaround
+  namespace detail {
+    template<typename Container> struct msvc6_iterator {
+      typedef Container::iterator type;
+    };
+
+    template<> struct msvc6_iterator<int> {
+      typedef int *type;
+    };
+  }
+#endif
+
+  template<class Container,
+           class Holder = identity<Container>,
+           class Generator = vector_generator>
+  class container_proxy
+  {
+    typedef container_proxy<Container, Holder, Generator> self_type;
+    typedef typename Container::iterator raw_iterator;
+    typedef ::boost::detail::iterator_traits<raw_iterator> raw_iterator_traits;
+
+#if !defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    template<class C> friend class shared_proxy_impl;
+    template<class C, typename E, typename T, typename S, typename I>
+        friend class proxy_iterator;
+#endif
+
+  public:
+    typedef typename Holder::held_type held_type;
+
+    typedef typename Container::size_type size_type;
+    typedef typename Container::difference_type difference_type;
+
+    typedef shared_proxy_impl<self_type> shared_proxy;
+
+    typedef typename Container::value_type raw_value_type;
+
+    typedef element_proxy<self_type> value_type;
+    typedef value_type               reference;  // Already has ref. semantics
+
+    typedef const_element_proxy<self_type> const_value_type;
+    typedef const_value_type               const_reference; // Ref. semantics
+
+    typedef proxy_iterator <self_type, value_type, raw_iterator_traits,
+        size_type, raw_iterator> iterator;
+    typedef iterator const_iterator; // No const_iterator yet implemented
+
+  public:
+    // Constructors
+    template<typename Iter> container_proxy (Iter start, Iter finish)
+      // Define inline for MSVC6 compatibility
+      : m_held_obj (Holder::create()),
+      m_proxies ()
+    {
+      insert (begin(), start, finish);
+    }
+
+    container_proxy ();
+    explicit container_proxy (held_type const &h);
+
+    container_proxy (container_proxy const &);
+    container_proxy &operator= (container_proxy const &);
+    ~container_proxy ();
+
+    Container const &raw_container() const;   // OK to expose const reference
+
+    reference       at (size_type index);
+    const_reference at (size_type index) const;
+
+    reference       operator[] (size_type index)       { return at(index); }
+    const_reference operator[] (size_type index) const { return at(index); }
+
+    size_type size ()     const { return raw_container().size(); }
+    size_type capacity () const { return raw_container().capacity(); }
+    void reserve (size_type s);
+
+  public:
+    iterator begin() { return iterator (this, static_cast<size_type>(0)); }
+    iterator end() { return iterator (this, raw_container().size()); }
+
+    iterator erase (iterator);
+    iterator erase (iterator, iterator);
+    iterator insert (iterator, raw_value_type const &);
+
+    template<typename Iter> void insert (iterator iter, Iter from, Iter to)
+      // Define here for MSVC6 compatibility
+    {
+      // Forward insertion to the right overloaded version
+      typedef typename BOOST_ITERATOR_CATEGORY<Iter>::type category;
+      insert (iter, from, to, category());
+    }
+
+    void push_back (raw_value_type const &copy) { insert (end(), copy); }
+
+    value_type pop_back () {
+      value_type result = at (size() - 1);
+      erase (end() - 1);
+      return result;
+    }
+
+  public:
+    // These functions are useful only when client code has direct
+    // non-const acccess to the raw container (e.g. via an indirect
+    // holder supplied to our constructor). Any code that directly
+    // modifies the contents of the raw container (by replacing,
+    // inserting or erasing elements) must notify the container_proxy.
+
+    void detach_proxy (size_type index);
+    void detach_proxies (size_type from, size_type to);
+    // Call before overwriting element(s) in the raw container
+
+    void prepare_erase (size_type from, size_type to);
+    // Call before erasing elements directly from the raw container
+
+    void notify_insertion (size_type from, size_type to);
+    // Call after inserting elements directly into the raw container
+
+  public:
+    // Convenient replacement of elements (automatic proxy detachment)
+    void replace (size_type index, raw_value_type const &);
+    //    template<typename Iter> void replace (size_type index, Iter, Iter);
+
+    void swap_elements (size_type index1, size_type index2);
+
+    bool is_valid () const; // Check the class invariant (for testing purposes)
+
+  private:
+    // Overloads for insertions with/without useful std::distance
+    template<typename Iter>
+    void insert (iterator iter, Iter from, Iter to, std::forward_iterator_tag)
+      // Define here for MSVC6 compatibility
+    {
+      assert (iter.ptr == this);
+      size_type count = std::distance (from, to);
+
+      // Add empty proxy pointers for the new value(s) (could throw)
+      m_proxies.insert (m_proxies.begin() + iter.index, count, pointer_impl());
+
+      try
+        {
+          // Insert the new element(s) into the real container (could throw)
+          raw_container().insert(
+              raw_container().begin() + iter.index,
+              from,
+              to);
+
+          try
+            {
+              // Create new proxies for the new elements (could throw)
+              write_proxies (iter.index, iter.index + count);
+            }
+
+          catch (...)
+            {
+              raw_container().erase(
+                  raw_container().begin() + iter.index,
+                  raw_container().begin() + iter.index + count);
+
+              throw;
+            }
+        }
+
+      catch (...)
+        {
+          m_proxies.erase(
+              m_proxies.begin() + iter.index,
+              m_proxies.begin() + iter.index + count);
+
+          throw;
+        }
+
+      // Adjust any proxies after the inserted elements (nothrow)
+      adjust_proxies(
+          m_proxies.begin() + iter.index + count,
+          m_proxies.end(),
+          static_cast<difference_type> (count));
+    }
+
+    template<typename Iter>
+    void insert (iterator iter, Iter from, Iter to, std::input_iterator_tag)
+      // Define here for MSVC6 compatibility
+    {
+      // insert overload for iterators where we *can't* get distance()
+      // so just insert elements one at a time
+      while (from != to)
+        {
+          iter = insert (iter, *from++) + 1;
+        }
+    }
+
+  private:
+    typedef boost::shared_ptr<shared_proxy> pointer_impl;
+
+    typedef typename mpl::apply1<Generator, pointer_impl>::type
+      pointer_container;
+
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+    typedef detail::msvc6_iterator<pointer_container>::type pointer_iterator;
+#else
+    typedef typename pointer_container::iterator pointer_iterator;
+#endif
+
+#if defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    // Proxies need mutable access, and can't be friends with MSVC6
+  public:
+#endif
+    Container &raw_container();
+
+  private:
+    void adjust_proxies (pointer_iterator, pointer_iterator, difference_type);
+    void write_proxies (size_type, size_type);
+    bool clear_proxy (pointer_impl &);         // detach and do not reset
+    void clear_proxies (size_type, size_type); // detach and do not reset
+    void claim_all_proxies (); // Makes all proxies point at this object
+
+  private:
+    held_type m_held_obj;
+    pointer_container m_proxies;
+  };
+
+  template<class Container, class Holder, class Generator>
+  container_proxy<Container, Holder, Generator>
+  ::container_proxy ()
+    : m_held_obj (Holder::create()),
+    m_proxies ()
+  {
+    // Container is empty - no further processing
+  }
+
+  template<class Container, class Holder, class Generator>
+  container_proxy<Container, Holder, Generator>
+  ::container_proxy (held_type const &held)
+    : m_held_obj (Holder::copy (held)),
+    m_proxies (size())
+  {
+    write_proxies (0, size());
+  }
+
+  template<class Container, class Holder, class Generator>
+  container_proxy<Container, Holder, Generator>
+  ::container_proxy (container_proxy const &copy)
+    : m_held_obj (Holder::copy (copy.m_held_obj)),
+    m_proxies (size())
+  {
+    write_proxies (0, size()); // Create our own proxies for the copied values
+  }
+
+  template<class Container, class Holder, class Generator>
+  container_proxy<Container, Holder, Generator> &
+  container_proxy<Container, Holder, Generator>
+  ::operator= (container_proxy const &copy)
+  {
+    container_proxy<Container, Holder, Generator> temp (copy);
+    // This could throw, but none of the remaining operations can
+
+    Holder::swap (m_held_obj, temp.m_held_obj);
+    std::swap (m_proxies, temp.m_proxies);
+
+    claim_all_proxies ();
+    temp.claim_all_proxies ();  // Prepare for detach
+
+    return *this;
+    // temp destruction detaches any proxies that used to belong to us
+  }
+
+  template<class Container, class Holder, class Generator>
+  container_proxy<Container, Holder, Generator>
+  ::~container_proxy ()
+  {
+    // Copy original values into any proxies being shared by external pointers
+    clear_proxies (0, size());
+    Holder::pre_destruction (m_held_obj);
+  }
+
+  template<class Container, class Holder, class Generator>
+  Container &
+  container_proxy<Container, Holder, Generator>
+  ::raw_container ()
+  {
+    return Holder::get (m_held_obj);
+  }
+
+  template<class Container, class Holder, class Generator>
+  Container const &
+  container_proxy<Container, Holder, Generator>
+  ::raw_container () const
+  {
+    return Holder::get (m_held_obj);
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::reserve (size_type size)
+  {
+    raw_container().reserve (size);
+    m_proxies.reserve (size);
+  }
+
+  template<class Container, class Holder, class Generator>
+  BOOST_DEDUCED_TYPENAME container_proxy<Container, Holder, Generator>::reference
+  container_proxy<Container, Holder, Generator>
+  ::at (size_type index)
+  {
+    pointer_impl const &ptr = m_proxies.BOOST_PYTHON_INDEXING_AT (index);
+    assert (ptr->owner() == this);
+    assert (ptr->index() == index);
+    return reference (ptr);
+  }
+
+  template<class Container, class Holder, class Generator>
+  BOOST_DEDUCED_TYPENAME container_proxy<Container, Holder, Generator>::const_reference
+  container_proxy<Container, Holder, Generator>
+  ::at (size_type index) const
+  {
+    pointer_impl const &ptr = m_proxies.BOOST_PYTHON_INDEXING_AT (index);
+    assert (ptr->owner() == this);
+    assert (ptr->index() == index);
+    return const_reference (ptr);
+  }
+
+  template<class Container, class Holder, class Generator>
+  void
+  container_proxy<Container, Holder, Generator>
+  ::replace (size_type index, raw_value_type const &copy)
+  {
+    detach_proxy (index);
+    raw_container().BOOST_PYTHON_INDEXING_AT (index) = copy;
+    write_proxies (index, index + 1);
+  }
+
+  template<class Container, class Holder, class Generator>
+  void
+  container_proxy<Container, Holder, Generator>
+  ::swap_elements (size_type index1, size_type index2)
+  {
+    pointer_impl &ptr1 = m_proxies[index1];
+    pointer_impl &ptr2 = m_proxies[index2];
+
+    assert (ptr1->owner() == this);
+    assert (ptr2->owner() == this);
+    assert (ptr1->index() == index1);
+    assert (ptr2->index() == index2);
+
+    // Swap produces the diagrammed transformation. Any external
+    // pointers that refer to proxy1 or proxy2 will end up still
+    // pointing to their original (now relocated) values.
+    //
+    // .. ptr1 .. ptr2 ..     .. ptr1 .. ptr2  ..  (m_proxies)
+    //      |      |                 \  /
+    //      |      |                  \/
+    //      |      |                  /\.
+    //      V      V                 /  \.
+    //   proxy1  proxy2  -->    proxy1  proxy2
+    //      |      |                 \  /
+    //      |      |                  \/
+    //      |      |                  /\.
+    //      V      V                 /  \.
+    //  .. v1 ... v2 ..         .. v2 .. v1 ..  (raw_container)
+
+    std::swap (ptr1->m_index, ptr2->m_index);
+    std::swap (ptr1, ptr2);
+    std::swap (raw_container()[index1], raw_container()[index2]);
+
+    assert (m_proxies[index1]->index() == index1);
+    assert (m_proxies[index2]->index() == index2);
+  }
+
+  template<class Container, class Holder, class Generator>
+  BOOST_DEDUCED_TYPENAME container_proxy<Container, Holder, Generator>::iterator
+  container_proxy<Container, Holder, Generator>::erase (iterator iter)
+  {
+    return erase (iter, iter + 1);
+  }
+
+  template<class Container, class Holder, class Generator>
+  BOOST_DEDUCED_TYPENAME container_proxy<Container, Holder, Generator>::iterator
+  container_proxy<Container, Holder, Generator>::erase(
+      iterator from, iterator to)
+  {
+    assert (from.ptr == this);
+    assert (to.ptr == this);
+
+    // Detach and remove the proxies for the about-to-be-erased elements
+    prepare_erase (from.index, to.index);
+
+    // Erase the elements from the real container
+    raw_iterator result
+      = raw_container().erase(
+          raw_container().begin() + from.index,
+          raw_container().begin() + to.index);
+
+    return iterator (this, result);
+  }
+
+  template<class Container, class Holder, class Generator>
+  BOOST_DEDUCED_TYPENAME container_proxy<Container, Holder, Generator>::iterator
+  container_proxy<Container, Holder, Generator>::insert(
+      iterator iter, raw_value_type const &copy)
+  {
+    // Use the iterator-based version by treating the value as an
+    // array of size one (see section 5.7/4 of the C++98 standard)
+    insert (iter, &copy, (&copy) + 1, std::random_access_iterator_tag());
+
+    return iter;
+  }
+
+  template<class Container, class Holder, class Generator>
+  bool container_proxy<Container, Holder, Generator>::clear_proxy(
+      pointer_impl &ptr)
+  {
+    // Warning - this can break the class invariant. Use only when the
+    // pointer is about to be overwritten or removed from m_proxies
+
+    assert (ptr->owner() == this);
+
+    if (!ptr.unique())
+      {
+        ptr->detach (); // Cause proxy to copy element value
+        return true;
+      }
+
+    else
+      {
+        // If the pointer isn't shared, don't bother causing a copy of
+        // the container element, since the proxy is about to be
+        // deleted or reused.
+        return false;
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::clear_proxies(
+      size_type from_index, size_type to_index)
+  {
+    while (from_index != to_index)
+      {
+        clear_proxy (m_proxies[from_index]);
+        ++from_index;
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>
+  ::detach_proxy (size_type index)
+  {
+    pointer_impl &ptr = m_proxies[index];
+
+    assert (ptr->index() == index);
+
+    if (clear_proxy (ptr))
+      {
+        // To maintain class invariant
+        ptr.reset (new shared_proxy (this, index));
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::detach_proxies(
+      size_type from_index, size_type to_index)
+  {
+    while (from_index != to_index)
+      {
+        detach_proxy (from_index);
+        ++from_index;
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>
+  ::prepare_erase (size_type from_index, size_type to_index)
+  {
+    difference_type deleting = to_index - from_index;
+    pointer_iterator erase_begin = m_proxies.begin() + from_index;
+    pointer_iterator erase_end = m_proxies.begin() + to_index;
+
+    // Adjust the indexes of any trailing proxies
+    adjust_proxies (erase_end, m_proxies.end(), -deleting);
+
+    // Detach any proxies without updating our pointers to them
+    clear_proxies (from_index, to_index);
+
+    // Remove the pointers
+    m_proxies.erase (erase_begin, erase_end);
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::notify_insertion(
+      size_type from_index, size_type to_index)
+  {
+    size_type count = to_index - from_index;
+
+    m_proxies.insert(
+        m_proxies.begin() + from_index, count, pointer_impl());
+
+    try
+      {
+        write_proxies (from_index, to_index); // Could throw
+      }
+
+    catch (...)
+      {
+        m_proxies.erase(
+            m_proxies.begin() + from_index,
+            m_proxies.begin() + to_index);
+
+        throw;
+      }
+
+    // Adjust any proxies after the inserted elements (nothrow)
+    adjust_proxies(
+        m_proxies.begin() + to_index,
+        m_proxies.end(),
+        static_cast<difference_type> (count));
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::adjust_proxies(
+      pointer_iterator from,
+      pointer_iterator to,
+      difference_type offset)
+  {
+    while (from != to)
+      {
+        (*from)->m_index += offset;
+        ++from;
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::write_proxies(
+      size_type from, size_type to)
+  {
+    // (over)write proxy pointers in the given range. Re-uses existing
+    // shared_proxy objects where possible. Does not call detach_proxy
+    // since it is assumed that the original values could have already
+    // been modified and copying them now would be wrong.
+
+    while (from != to)
+      {
+        pointer_impl &ptr = m_proxies[from];
+
+        if ((ptr.get() == 0) || (!ptr.unique()))
+          {
+            // Either no proxy yet allocated here, or there is one
+            // but it is being shared by an external pointer.
+            ptr.reset (new shared_proxy (this, from));
+          }
+
+        else
+          {
+            // Re-use the existing object since we have the only pointer to it
+            assert (ptr->owner() == this);
+            ptr->m_index = from;
+          }
+
+        ++from;
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  void container_proxy<Container, Holder, Generator>::claim_all_proxies ()
+  {
+    for (pointer_iterator iter = m_proxies.begin();
+         iter != m_proxies.end();
+         ++iter)
+      {
+        (*iter)->m_owner_ptr = this;
+      }
+  }
+
+  template<class Container, class Holder, class Generator>
+  bool container_proxy<Container, Holder, Generator>::is_valid () const
+  {
+    bool ok = size() == m_proxies.size(); // Sizes must match
+
+    for (size_type count = 0; ok && (count < size()); ++count)
+      {
+        pointer_impl const &ptr = m_proxies[count];
+
+        ok = ptr.get() && (ptr->owner() == this) && (ptr->index() == count)
+          && !ptr->m_element_ptr.get();
+      }
+
+    return ok;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for container_proxy instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container>
+  struct container_proxy_traits : random_access_sequence_traits<Container>
+  {
+    typedef Container container;
+    typedef typename container::raw_value_type value_type; // insert, ...
+    typedef typename container::raw_value_type key_type;   // find, count, ...
+    typedef typename container::reference reference;  // return values
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <value_type>::param_type
+        value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <key_type>::param_type
+        key_param;
+
+#if defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+    // value_traits for the reference type (i.e. our element_proxy
+    // instance) supplies a custom visit_container_class. Compilers
+    // without partial specialization need help here.
+
+    typedef element_proxy_traits<Container> value_traits_type;
+
+    // Hide base class visit_container_class, which would call the
+    // unspecialized value_traits version
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class(
+        PythonClass &pyClass, Policy const &policy)
+    {
+      value_traits_type::visit_container_class (pyClass, policy);
+    }
+#endif
+  };
+
+#if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for container_proxy instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <typename RawContainer, typename Holder, typename Generator>
+    class algorithms_selector<container_proxy<RawContainer, Holder, Generator> >
+    {
+      typedef container_proxy<RawContainer, Holder, Generator> Container;
+
+      typedef container_proxy_traits<Container>       mutable_traits;
+      typedef container_proxy_traits<Container const> const_traits;
+
+    public:
+      typedef default_algorithms<mutable_traits> mutable_algorithms;
+      typedef default_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+  template<
+      class Container,
+      method_set_type MethodMask = all_methods,
+      class Traits = container_proxy_traits<Container>
+  >
+  struct container_proxy_suite
+    : container_suite<Container, MethodMask, default_algorithms<Traits> >
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_CONTAINER_PROXY_HPP
--- boost/python/suite/indexing/container_suite.hpp	(revision 6923)
+++ boost/python/suite/indexing/container_suite.hpp	(revision 6923)
@@ -0,0 +1,53 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file container_suite.hpp
+//
+// Top-level interface to the container suite.
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation
+// 2003/ 9/ 8   rmg     Extracted trait facilities into container_traits.hpp
+//
+// $Id: container_suite.hpp,v 1.1.2.7 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP
+#define BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP
+
+#include <boost/python/suite/indexing/methods.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <boost/python/suite/indexing/visitor.hpp>
+
+#include <boost/python/return_by_value.hpp>
+#include <boost/python/return_value_policy.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  typedef boost::python::return_value_policy<boost::python::return_by_value>
+  default_container_policies;
+
+  template<
+      class Container,
+      method_set_type MethodMask = all_methods,  // All supported by algorithms
+      class Algorithms
+          = algorithms<Container>
+  >
+  struct container_suite
+    : public visitor<Algorithms, default_container_policies, MethodMask>
+  {
+    typedef Algorithms algorithms;
+
+    template<typename Policy>
+    static visitor<Algorithms, Policy, MethodMask>
+    with_policies (Policy const &policy)
+    {
+      return visitor <Algorithms, Policy, MethodMask> (policy);
+    }
+  };
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP
--- boost/python/suite/indexing/set.hpp	(revision 6923)
+++ boost/python/suite/indexing/set.hpp	(revision 6923)
@@ -0,0 +1,167 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file set.hpp
+//
+// Indexing algorithms support for std::set instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: set.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SET_HPP
+#define BOOST_PYTHON_INDEXING_SET_HPP
+
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <boost/type_traits/is_const.hpp>
+#include <set>
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::set instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container>
+  class set_traits : public base_container_traits<Container>
+  {
+    typedef base_container_traits<Container> base_class;
+
+  public:
+    typedef typename Container::key_type value_type; // probably unused
+    typedef typename Container::key_type index_type; // operator[]
+    typedef typename Container::key_type key_type;   // find, count, ...
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <value_type>::param_type
+        value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <key_type>::param_type
+        key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <index_type>::param_type
+        index_param;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_iter
+            | method_getitem
+            | method_contains
+            | method_count
+            | method_has_key
+
+            | detail::method_set_if<
+                  base_class::is_mutable,
+                    method_delitem
+                  | method_insert
+              >::value
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::set instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr = detail::no_override>
+  class set_algorithms
+    : public assoc_algorithms
+        <ContainerTraits,
+        typename detail::maybe_override
+            <set_algorithms<ContainerTraits, Ovr>, Ovr>
+          ::type>
+  {
+    typedef set_algorithms<ContainerTraits, Ovr> self_type;
+    typedef typename detail::maybe_override<self_type, Ovr>::type most_derived;
+    typedef assoc_algorithms<ContainerTraits, most_derived> Parent;
+
+  public:
+    typedef typename Parent::container container;
+    typedef typename Parent::value_param value_param;
+    typedef typename Parent::index_param index_param;
+
+    static void      insert     (container &, index_param);
+  
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class( PythonClass &pyClass, Policy const &policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+      pyClass.def( "add", &self_type::insert );        
+    }  
+
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::set instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class Key, class Compare, class Allocator>
+    class algorithms_selector<std::set<Key, Compare, Allocator> >
+    {
+      typedef std::set<Key, Compare, Allocator> Container;
+
+      typedef set_traits<Container>       mutable_traits;
+      typedef set_traits<Container const> const_traits;
+
+    public:
+      typedef set_algorithms<mutable_traits> mutable_algorithms;
+      typedef set_algorithms<const_traits>   const_algorithms;
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::multiset instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <class Key, class Compare, class Allocator>
+    class algorithms_selector<std::multiset<Key, Compare, Allocator> >
+    {
+      typedef std::multiset<Key, Compare, Allocator> Container;
+
+      typedef set_traits<Container>       mutable_traits;
+      typedef set_traits<Container const> const_traits;
+
+    public:
+      typedef set_algorithms<mutable_traits> mutable_algorithms;
+      typedef set_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = set_traits<Container>
+  >
+  struct set_suite
+    : container_suite<Container, MethodMask, set_algorithms<Traits> >
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert an element into a set
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  set_algorithms<ContainerTraits, Ovr>::insert(
+      container &c, index_param ix)
+  {
+    c.insert (ix);
+    //~ Python set does not raise exception in this situation
+    //~ if (!c.insert (ix).second)
+      //~ {
+        //~ PyErr_SetString(
+            //~ PyExc_ValueError, "Set already holds value for insertion");
+
+        //~ boost::python::throw_error_already_set ();
+      //~ }
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SET_HPP
--- boost/python/suite/indexing/workaround.hpp	(revision 6923)
+++ boost/python/suite/indexing/workaround.hpp	(revision 6923)
@@ -0,0 +1,46 @@
+// Header file workaround.hpp
+//
+// Indexing-specific workarounds for compiler problems.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/10/21   rmg     File creation
+//
+// $Id: workaround.hpp,v 1.1.2.3 2003/11/17 19:27:13 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_WORKAROUND_HPP
+#define BOOST_PYTHON_INDEXING_WORKAROUND_HPP
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+# if (BOOST_WORKAROUND (__GNUC__, < 3))
+#   // gcc versions before 3 (like 2.95.3) don't have the "at" member
+#   // function in std::vector or std::deque
+#   define BOOST_PYTHON_INDEXING_AT operator[]
+# else
+#   define BOOST_PYTHON_INDEXING_AT at
+# endif
+
+# if BOOST_WORKAROUND (BOOST_MSVC, <= 1300)
+// Workaround the lack of a reset member function in std::auto_ptr
+namespace boost { namespace python { namespace indexing {
+template<typename T> void reset_auto_ptr (T &aptr, T::element_type *pptr) {
+ aptr = T (pptr);
+}
+} } }
+#   define BOOST_PYTHON_INDEXING_RESET_AUTO_PTR \
+        ::boost::python::indexing::reset_auto_ptr
+# else
+#   define BOOST_PYTHON_INDEXING_RESET_AUTO_PTR( aptr, pptr ) \
+        (aptr).reset(pptr)
+# endif
+
+#endif // BOOST_PYTHON_INDEXING_WORKAROUND_HPP
--- boost/python/suite/indexing/slice.hpp	(revision 6923)
+++ boost/python/suite/indexing/slice.hpp	(revision 6923)
@@ -0,0 +1,103 @@
+// Header file slice.hpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: slice.hpp,v 1.1.2.10 2003/11/24 14:28:31 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SLICE_HPP
+#define BOOST_PYTHON_INDEXING_SLICE_HPP
+
+#include <boost/python/object.hpp>
+#include <boost/python/errors.hpp>
+#include <boost/python/converter/pytype_object_mgr_traits.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  struct BOOST_PYTHON_DECL slice : public boost::python::object
+  {
+    // This is just a thin wrapper around boost::python::object
+    // so that it is possible to register a special converter for
+    // PySlice_Type and overload C++ functions on slice
+
+#if defined (BOOST_NO_MEMBER_TEMPLATES)
+    // MSVC6 doesn't seem to be able to invoke the templated
+    // constructor, so provide explicit overloads to match the
+    // (currently) known boost::python::object constructors
+    explicit slice (::boost::python::handle<> const&);
+    explicit slice (::boost::python::detail::borrowed_reference);
+    explicit slice (::boost::python::detail::new_reference);
+    explicit slice (::boost::python::detail::new_non_null_reference);
+#else
+    // Better compilers make life easier
+    template<typename T> inline slice (T const &ref);
+#endif
+
+    slice (slice const &); // Copy constructor
+  };
+
+  struct BOOST_PYTHON_DECL integer_slice
+  {
+    // This class provides a convenient interface to Python slice
+    // objects that contain integer bound and stride values.
+
+    #if PY_VERSION_HEX < 0x02050000
+        typedef int index_type;
+    #else
+        typedef Py_ssize_t index_type;
+    #endif
+
+    integer_slice (slice const &, index_type length);
+    // integer_slice must know how big the container is so it can
+    // adjust for negative indexes, etc...
+
+    index_type start() const { return m_start; }
+    index_type step() const  { return m_step; }
+    index_type stop() const  { return m_stop; }
+
+    index_type size() const { return (m_stop - m_start) / m_step; }
+
+    bool in_range (index_type index);
+
+  private:
+    slice m_slice;
+    index_type m_start;
+    index_type m_step;
+    index_type m_stop;
+    index_type m_direction;
+  };
+} } }
+
+#if !defined (BOOST_NO_MEMBER_TEMPLATES)
+template<typename T>
+boost::python::indexing::slice::slice (T const &ref)
+  : boost::python::object (ref)
+{
+  if (!PySlice_Check (this->ptr()))
+    {
+      PyErr_SetString(
+          PyExc_TypeError, "slice constructor: passed a non-slice object");
+
+      boost::python::throw_error_already_set();
+    }
+}
+#endif
+
+namespace boost { namespace python { namespace converter {
+  // Specialized converter to handle PySlice_Type objects
+  template<>
+  struct object_manager_traits<boost::python::indexing::slice>
+    : pytype_object_manager_traits<
+         &PySlice_Type, ::boost::python::indexing::slice>
+  {
+  };
+}}}
+
+#endif // BOOST_PYTHON_INDEXING_SLICE_HPP
--- boost/python/suite/indexing/visitor.hpp	(revision 6923)
+++ boost/python/suite/indexing/visitor.hpp	(revision 6923)
@@ -0,0 +1,271 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file visitor.hpp:
+//
+// def_visitor implementation to install the container_suite's Python
+// methods in an object of a boost::python::class_<> instance.
+//
+// History
+// =======
+// 2003/ 9/11   rmg     File creation from container_suite.hpp
+//
+// $Id: visitor.hpp,v 1.1.2.16 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_VISITOR_HPP
+#define BOOST_PYTHON_INDEXING_VISITOR_HPP
+
+#include <boost/python/suite/indexing/slice_handler.hpp>
+#include <boost/python/suite/indexing/suite_utils.hpp> // Get index_style_t
+
+#include <boost/python/def_visitor.hpp>
+#include <boost/python/iterator.hpp>
+#include <boost/python/default_call_policies.hpp>
+#include <boost/type_traits/ice.hpp>
+#include <boost/bind.hpp>
+#include <functional>
+
+namespace boost { namespace python { namespace indexing {
+  //////////////////////////////////////////////////////////////////////////
+  // Policy override template that masks everything except the precall
+  // functions. i.e. it uses default policies for everything except
+  // precall, which must be provided by the template argument.
+  //////////////////////////////////////////////////////////////////////////
+
+  namespace detail {
+    template<typename PrecallPolicy>
+    struct precall_only : public boost::python::default_call_policies
+    {
+      precall_only () : m_precall () { }
+      explicit precall_only (PrecallPolicy const &copy) : m_precall (copy) { }
+
+      bool precall (PyObject *args) { return m_precall.precall (args); }
+      bool precall (PyObject *args) const { return m_precall.precall (args); }
+
+    private:
+      PrecallPolicy m_precall;
+    };
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Ugly macro to define a template that optionally adds a method to
+  // a Python class. This version (OPTIONAL_ALGO_SUPPORT) works with
+  // static functions in an Algorithms class.
+  //
+  // This macro is #undef'd at the end of this header
+  //////////////////////////////////////////////////////////////////////////
+
+#define OPTIONAL_ALGO_SUPPORT(ADDER_NAME, METHOD_NAME, ALGO_FN) \
+  template<bool doit>  \
+  struct ADDER_NAME {  \
+    template<class PythonClass, class Algorithms, class Policy>  \
+    static void apply (PythonClass &, Algorithms const &, Policy const &)  \
+    {  \
+    }  \
+  };  \
+\
+  template<>  \
+  struct ADDER_NAME<true> {  \
+    template<class PythonClass, class Algorithms, class Policy>  \
+    static void apply(  \
+        PythonClass &pyClass,  \
+        Algorithms const &,  \
+        Policy const &policy)  \
+    {  \
+      pyClass.def (METHOD_NAME, &Algorithms::ALGO_FN, policy);  \
+    }  \
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Ugly macro to define a template that optionally adds a method to
+  // a Python class. This version (OPTIONAL_SLICE_SUPPORT) works with
+  // static functions in the slice_handler template.
+  //
+  // This macro is #undef'd at the end of this header
+  //////////////////////////////////////////////////////////////////////////
+
+#define OPTIONAL_SLICE_SUPPORT(ADDER_NAME, METHOD_NAME, SLICE_HANDLER_FN) \
+  template<bool doit>  \
+  struct ADDER_NAME {  \
+    template<class PythonClass, class Algorithms, class Policy>  \
+    static void apply (PythonClass &, Algorithms const &, Policy const &)  \
+    {  \
+    }  \
+  };  \
+\
+  template<>  \
+  struct ADDER_NAME<true> {  \
+    template<class PythonClass, class Algorithms, class Policy>  \
+    static void apply(  \
+        PythonClass &pyClass,  \
+        Algorithms const &,  \
+        Policy const &policy)  \
+    {  \
+      pyClass.def ( \
+          METHOD_NAME, \
+          slice_handler<Algorithms, Policy>::SLICE_HANDLER_FN (policy));  \
+    }  \
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // __iter__ is a special case not handled by the above macros. First
+  // the unspecialized (do-nothing) version
+  //////////////////////////////////////////////////////////////////////////
+
+  template<bool doit>
+  struct maybe_add_iter {
+    template<class PythonClass, class Algorithms, class Policy>
+    static void apply (PythonClass &, Algorithms const &, Policy const &) { }
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Specialization with the real implementation of __iter__
+  //////////////////////////////////////////////////////////////////////////
+
+  template<>
+  struct maybe_add_iter<true> {
+    template<class PythonClass, class Algorithms, class Policy>
+    static void apply(
+        PythonClass &pyClass,
+        Algorithms const &,
+        Policy const &)
+    {
+      // Should maybe separate precall and postcall portions of the
+      // policy (precall when generating the range object, postcall
+      // when returing from range.next())?
+
+      pyClass.def(
+          "__iter__",
+          boost::python::range<Policy>(
+              Algorithms::begin,
+              Algorithms::end));
+    }
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // All other optional methods are covered by the two OPTIONAL_*
+  // macros
+  //////////////////////////////////////////////////////////////////////////
+
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_len, "__len__", size);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_getitem, "__getitem__", get);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_setitem, "__setitem__", assign);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_delitem, "__delitem__", erase_one);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_getslice, "__getitem__", make_getitem);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_setslice, "__setitem__", make_setitem);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_delslice, "__delitem__", make_delitem);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_sort, "sort", sort);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_reverse, "reverse", reverse);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_append, "append", push_back);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_insert, "insert", insert);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_extend, "extend", make_extend);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_index, "index", get_index);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_count, "count", count);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_contains, "__contains__", contains);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_has_key, "has_key", contains);
+
+  //////////////////////////////////////////////////////////////////////////
+  // Do-all visitor
+  //////////////////////////////////////////////////////////////////////////
+
+  template<class Algorithms, class Policy, method_set_type MethodMask>
+  class visitor
+    : public def_visitor< visitor< Algorithms, Policy, MethodMask > >
+  {
+    Policy m_policy;
+
+    BOOST_STATIC_CONSTANT (
+        method_set_type,
+        enabled_methods = Algorithms::supported_methods & MethodMask);
+
+  public:
+    typedef Algorithms algorithms_type;
+
+    explicit visitor (Policy const &policy = Policy()) : m_policy (policy) { }
+
+  public:
+    template <class PythonClass>
+    void visit (PythonClass &pyClass) const
+    {
+      detail::precall_only<Policy> precallPolicy (m_policy);
+
+      maybe_add_len<detail::is_member<enabled_methods, method_len>::value>
+        ::apply(pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_getitem<
+        detail::is_member<enabled_methods, method_getitem>::value
+      >::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_getslice<
+          detail::is_member<enabled_methods, method_getitem_slice>::value
+      >::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_setitem<
+        detail::is_member<enabled_methods, method_setitem>::value
+      >::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_setslice<
+          detail::is_member<enabled_methods, method_setitem_slice>::value
+      >::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_delitem<
+        detail::is_member<enabled_methods, method_delitem>::value
+      >::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_delslice<
+          detail::is_member<enabled_methods, method_delitem_slice>::value
+      >::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_iter<
+        detail::is_member<enabled_methods, method_iter>::value
+      >::apply (pyClass, algorithms_type(), m_policy);
+
+      maybe_add_sort<
+        detail::is_member<enabled_methods, method_sort>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_reverse<
+        detail::is_member<enabled_methods, method_reverse>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_append<
+        detail::is_member<enabled_methods, method_append>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_insert<
+        detail::is_member<enabled_methods, method_insert>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_extend<
+        detail::is_member<enabled_methods, method_extend>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_index<
+        detail::is_member<enabled_methods, method_index>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_count<
+        detail::is_member<enabled_methods, method_count>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_contains<
+        detail::is_member<enabled_methods, method_contains>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_has_key<
+        detail::is_member<enabled_methods, method_has_key>::value
+      >::apply (pyClass, algorithms_type(), precallPolicy);
+
+      Algorithms::visit_container_class (pyClass, m_policy);
+    }
+  };
+} } }
+
+#undef OPTIONAL_SLICE_SUPPORT
+#undef OPTIONAL_ALGO_SUPPORT
+
+#endif // BOOST_PYTHON_INDEXING_VISITOR_HPP
--- boost/python/suite/indexing/iterator_range.hpp	(revision 6923)
+++ boost/python/suite/indexing/iterator_range.hpp	(revision 6923)
@@ -0,0 +1,260 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file iterator_range.hpp
+//
+// Emulate an STL container using a pair of iterators. Doesn't support
+// insertion or deletion, for the obvious reasons.
+//
+// History
+// =======
+// 2003/ 9/ 9   rmg     File creation as iterator_pair.hpp
+// 2003/10/27   rmg     Renamed iterator_range.hpp
+//
+// $Id: iterator_range.hpp,v 1.1.2.7 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ITERATOR_RANGE_HPP
+#define BOOST_PYTHON_INDEXING_ITERATOR_RANGE_HPP
+
+#include <stdexcept>
+#include <algorithm>
+#include <utility>
+#include <boost/type_traits.hpp>
+#include <boost/type_traits/ice.hpp>
+#include <boost/detail/workaround.hpp>
+#include <boost/iterator/iterator_traits.hpp>
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <boost/python/suite/indexing/iterator_traits.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  template<typename Iterator>
+  class iterator_range
+  {
+  private:
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <Iterator>::param_type
+        iterator_param;
+
+    typedef ::boost::detail::iterator_traits<Iterator> std_traits;
+
+  public:
+    typedef typename std_traits::reference       reference;
+    typedef Iterator                             iterator;
+    typedef typename std_traits::difference_type size_type;
+    typedef typename std_traits::difference_type difference_type;
+    typedef typename std_traits::value_type      value_type;
+    typedef typename std_traits::pointer         pointer;
+
+    typedef iterator                             const_iterator;
+    // Can't tell what the const version of our iterator should
+    // be. The client code will have to instantiate iterator_range
+    // directly with a const_iterator if that's what it wants.
+
+    // Also can't provide: allocator_type, reverse_iterator or
+    // const_reverse_iterator. Could probably provide (but don't)
+    // const_reference and const_pointer. These would be the same as
+    // reference and pointer if Iterator is itself a const_iterator.
+
+  public:
+    iterator_range (iterator_param, iterator_param);
+    iterator_range (std::pair<iterator, iterator> const &);
+
+    iterator begin() const;
+    iterator end() const;
+
+  public:
+    // Only sensible for random_access iterators
+    size_type size () const;
+    reference operator[] (size_type) const;
+    reference at (size_type) const;
+
+  private:
+    iterator m_begin;
+    iterator m_end;
+  };
+
+  // Array support function(s).
+  template<typename T> iterator_range<T *> make_iterator_range (T *, T*);
+
+#if !BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+  template<typename T, std::size_t N> iterator_range<T *> make_iterator_range(
+      T (&array)[N]);
+
+  template<typename T, std::size_t N> T *begin (T (&array)[N]);
+  template<typename T, std::size_t N> T *end   (T (&array)[N]);
+
+# define BOOST_MAKE_ITERATOR_RANGE \
+      ::boost::python::indexing::make_iterator_range
+
+#else
+  // For compilers that can't deduce template argument array bounds
+# define BOOST_MAKE_ITERATOR_RANGE(array) \
+      ::boost::python::indexing::make_iterator_range ( \
+          (array), ((array) + sizeof(array) / sizeof((array)[0])))
+#endif
+
+  template<typename Iterator>
+  iterator_range<Iterator>::iterator_range(
+      iterator_param begin, iterator_param end)
+    : m_begin (begin),
+    m_end (end)
+  {
+  }
+
+  template<typename Iterator>
+  iterator_range<Iterator>
+  ::iterator_range (std::pair<iterator, iterator> const &pair)
+    : m_begin (pair.first),
+    m_end (pair.second)
+  {
+  }
+
+  template<typename Iterator>
+  typename iterator_range<Iterator>::iterator
+  iterator_range<Iterator>::begin() const
+  {
+    return m_begin;
+  }
+
+  template<typename Iterator>
+  typename iterator_range<Iterator>::iterator
+  iterator_range<Iterator>::end() const
+  {
+    return m_end;
+  }
+
+  template<typename Iterator>
+  typename iterator_range<Iterator>::size_type
+  iterator_range<Iterator>::size() const
+  {
+    return std::distance (begin(), end());
+  }
+
+  template<typename Iterator>
+  typename iterator_range<Iterator>::reference
+  iterator_range<Iterator>::operator[](size_type index) const
+  {
+    iterator temp (begin());
+    std::advance (temp, index);
+    return *temp;
+  }
+
+  template<typename Iterator>
+  typename iterator_range<Iterator>::reference
+  iterator_range<Iterator>::at (size_type index) const
+  {
+    if (index >= size())
+      {
+        throw std::out_of_range
+          (std::string ("iterator_range: index out of range"));
+      }
+
+    else
+      {
+        return (*this)[index];
+      }
+  }
+
+  template<typename T> iterator_range<T *> make_iterator_range (T *p1, T* p2)
+  {
+    return iterator_range<T *> (p1, p2);
+  }
+
+#if !BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+  template<typename T, std::size_t N>
+  T *begin (T (&array)[N]) {
+    return array;
+  }
+
+  template<typename T, std::size_t N>
+  T *end (T (&array)[N]) {
+    return array + N;
+  }
+
+  template<typename T, std::size_t N>
+  iterator_range<T *> make_iterator_range (T (&array)[N]) {
+    return iterator_range<T *>(begin (array), end (array));
+  }
+#endif
+
+  template<typename Container, typename ValueTraits = detail::no_override>
+  class iterator_range_traits
+    : public base_container_traits<Container, ValueTraits>
+  {
+    typedef base_container_traits<Container, ValueTraits> base_class;
+
+    typedef ::boost::python::indexing::iterator_traits<
+      typename Container::iterator
+    > iterator_traits_type;
+
+  public:
+    typedef typename base_class::value_traits_type value_traits_type;
+
+  private:
+    // Methods that we *can't* support because of our value type
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        disabled_methods = (
+            detail::method_set_if<
+               type_traits::ice_not<
+                   value_traits_type::equality_comparable
+               >::value,
+                 method_index      // Impossible if !equality_comparable
+               | method_contains   // Impossible if !equality_comparable
+               | method_count      // Impossible if !equality_comparable
+            >::value
+
+          | detail::method_set_if<
+               type_traits::ice_not<
+                   value_traits_type::less_than_comparable
+               >::value,
+               method_sort         // Impossible if !less_than_comparable
+            >::value
+        ));
+
+  public:
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods =
+        iterator_traits_type::supported_methods & ~disabled_methods);
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for iterator_range instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template <typename Iterator>
+    class algorithms_selector<iterator_range<Iterator> >
+    {
+      typedef iterator_range<Iterator> Container;
+
+      typedef iterator_range_traits<Container>       mutable_traits;
+      typedef iterator_range_traits<Container const> const_traits; // ?
+
+    public:
+      typedef default_algorithms<mutable_traits> mutable_algorithms;
+      typedef default_algorithms<const_traits>   const_algorithms;
+    };
+  }
+#endif
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = iterator_range_traits<Container>
+  >
+  struct iterator_range_suite
+    : container_suite<Container, MethodMask, default_algorithms<Traits> >
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ITERATOR_RANGE_HPP
--- boost/python/suite/indexing/int_slice_helper.hpp	(revision 6923)
+++ boost/python/suite/indexing/int_slice_helper.hpp	(revision 6923)
@@ -0,0 +1,251 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file int_slice_helper.hpp
+//
+// History
+// =======
+// 2003/10/13   rmg     File creation
+//
+// $Id: int_slice_helper.hpp,v 1.1.2.10 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_INT_SLICE_HELPER_HPP
+#define BOOST_PYTHON_INDEXING_INT_SLICE_HELPER_HPP
+
+# include <boost/python/errors.hpp>
+# include <boost/python/suite/indexing/workaround.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  template<typename Algorithms, typename SliceType>
+  struct int_slice_helper
+  {
+    // Works with a SliceType that provides an int-like index_type
+    // that is convertible to the algorithm's index_param
+
+    typedef Algorithms algorithms_type;
+    typedef SliceType slice_type;
+
+    typedef typename algorithms_type::container container;
+    typedef typename algorithms_type::reference reference;
+    typedef typename algorithms_type::value_param value_param;
+    typedef typename algorithms_type::container_traits container_traits;
+    typedef typename slice_type::index_type index_type;
+
+    int_slice_helper (container &c, slice_type const &);
+
+    bool next();
+
+    reference current () const;
+    void write (value_param val);
+    void erase_remaining () const;
+
+  private:
+    void assign (value_param val) const;
+    void insert (value_param val);
+
+  private:
+    slice_type m_slice;
+    container *m_ptr;
+    index_type m_pos;
+  };
+
+  template<typename Algorithms, typename SliceType>
+  int_slice_helper<Algorithms, SliceType>
+  ::int_slice_helper (container &c, slice_type const &sl)
+    : m_slice (sl),
+    m_ptr (&c),
+    m_pos (-1)
+  {
+  }
+
+  template<typename Algorithms, typename SliceType>
+  bool
+  int_slice_helper<Algorithms, SliceType>::next()
+  {
+    bool result = false; // Assume the worst
+
+    if (m_pos == -1)
+      {
+        // First time call - get to start of the slice (if any)
+        m_pos = m_slice.start();
+        result = m_slice.in_range (m_pos);
+      }
+
+    else if (m_slice.in_range (m_pos))
+      {
+        // Subsequent calls - advance by the slice's stride
+        m_pos += m_slice.step();
+        result = m_slice.in_range (m_pos);
+      }
+
+    return result;
+  }
+
+  template<typename Algorithms, typename SliceType>
+  typename int_slice_helper<Algorithms, SliceType>::reference
+  int_slice_helper<Algorithms, SliceType>::current () const
+  {
+    return algorithms_type::get (*m_ptr, m_pos);
+  }
+
+  template<typename Algorithms, typename SliceType>
+  void int_slice_helper<Algorithms, SliceType>::write (value_param val)
+  {
+    if (next())
+      {
+        assign (val);
+      }
+
+    else
+      {
+        insert (val);
+      }
+  }
+
+  template<typename Algorithms, typename SliceType>
+  void int_slice_helper<Algorithms, SliceType>::assign (value_param val) const
+  {
+    algorithms_type::assign (*m_ptr, m_pos, val);
+  }
+
+  namespace detail {
+    template<bool doit> struct maybe_insert {
+
+      // NOTE: use the name "apply_" instead of "apply" to avoid
+      // weirdo compiler crash in mpl/aux_/apply.hpp on MSVC7. Don't
+      // even ask how I arrived at this fix :-)
+
+      template<class Algorithms>
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        && defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          // Can't explicitly instantiate member function - must let
+          // the compiler deduce the argument type from a dummy
+          // parameter. Same applies throughout
+          Algorithms *,
+# endif
+          typename Algorithms::container &,
+          typename Algorithms::index_param,
+          typename Algorithms::value_param)
+      {
+        PyErr_SetString(
+            PyExc_TypeError,
+            "container does not support insertion into slice");
+
+        boost::python::throw_error_already_set ();
+      }
+    };
+
+    template<> struct maybe_insert<true> {
+      template<class Algorithms>
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        && defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          Algorithms *,
+# endif
+          typename Algorithms::container &c,
+          typename Algorithms::index_param i,
+          typename Algorithms::value_param v)
+      {
+        Algorithms::insert (c, i, v);
+      }
+    };
+  }
+
+  template<typename Algorithms, typename SliceType>
+  void int_slice_helper<Algorithms, SliceType>::insert (value_param val)
+  {
+    if (m_slice.step() != 1)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, "attempt to insert via extended slice");
+
+        boost::python::throw_error_already_set ();
+      }
+
+    else
+      {
+        detail::maybe_insert<
+          detail::is_member<
+            container_traits::supported_methods, method_insert>::value>::
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+  && defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          apply_ (static_cast<Algorithms *>(0),
+# else
+          BOOST_NESTED_TEMPLATE apply_ <Algorithms>(
+# endif
+              *m_ptr, m_pos, val);
+
+        ++m_pos;  // Advance for any subsequent inserts
+      }
+  }
+
+  namespace detail {
+    template<bool doit> struct maybe_erase {
+      template<class Algorithms>
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        && defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          Algorithms *,
+# endif
+          typename Algorithms::container &,
+          typename Algorithms::index_param,
+          typename Algorithms::index_param)
+      {
+        PyErr_SetString(
+            PyExc_TypeError, "container does not support item deletion");
+
+        boost::python::throw_error_already_set ();
+      }
+    };
+
+    template<> struct maybe_erase<true> {
+      template<class Algorithms>
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        && defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          Algorithms *,
+# endif
+          typename Algorithms::container &c,
+          typename Algorithms::index_param from,
+          typename Algorithms::index_param to)
+      {
+        Algorithms::erase_range (c, from, to);
+      }
+    };
+  }
+
+  template<typename Algorithms, typename SliceType>
+  void int_slice_helper<Algorithms, SliceType>::erase_remaining () const
+  {
+    if (m_slice.step() != 1)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, "attempt to delete via extended slice");
+
+        boost::python::throw_error_already_set ();
+      }
+
+    else
+      {
+        detail::maybe_erase<
+          detail::is_member<
+            container_traits::supported_methods, method_delitem>::value>::
+
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+  && defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          apply_ (static_cast<Algorithms *>(0),
+# else
+          BOOST_NESTED_TEMPLATE apply_ <Algorithms>(
+# endif
+              *m_ptr, m_pos, m_slice.stop());
+      }
+  }
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_INT_SLICE_HELPER_HPP
--- boost/python/suite/indexing/suite_utils.hpp	(revision 6923)
+++ boost/python/suite/indexing/suite_utils.hpp	(revision 6923)
@@ -0,0 +1,110 @@
+// Header file suite_utils.hpp
+//
+// Shared utilities for the indexing suite.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation
+//
+// $Id: suite_utils.hpp,v 1.1.2.7 2003/11/24 14:28:31 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SUITE_UTILS_HPP
+#define BOOST_PYTHON_INDEXING_SUITE_UTILS_HPP
+
+#include <boost/type_traits.hpp>
+
+namespace boost { namespace python { namespace indexing {
+#if BOOST_WORKAROUND (BOOST_MSVC, BOOST_TESTED_AT (1310)) \
+  || (defined (__GNUC__) && (__GNUC__ < 3))
+  // MSVC and GCC 2.96 seem to have problems comparing enumerated
+  // values in a static constant expression, and don't believe that an
+  // expression like (traits::index_style >= index_style_nonlinear) is
+  // a compile-time constant. However, the problem doesn't exist for
+  // int.
+  typedef int index_style_t;
+  index_style_t const index_style_none = 0;
+  index_style_t const index_style_nonlinear = 1;
+  index_style_t const index_style_linear = 2;
+#else
+  enum index_style_t {
+    index_style_none,         // No random access (iteration only)
+    index_style_nonlinear,  // Random access by key (no slicing)
+    index_style_linear     // Random access by integer index (allows slicing)
+  };
+#endif
+
+  template<typename T>
+  class is_mutable_ref
+  {
+    typedef typename boost::remove_reference<T>::type maybe_const;
+
+  public:
+    BOOST_STATIC_CONSTANT (bool, value = !boost::is_const<maybe_const>::value);
+  };
+
+  // make_signed attempts to identify the signed version of any
+  // numeric type (useful in this case because Python container
+  // indexes can be negative).
+  template<typename T> struct make_signed {
+    typedef T type;
+  };
+
+  template<> struct make_signed<char> {
+    // Raw "char" could be signed or unsigned. "signed char"
+    // guarantess signedness
+    typedef signed char type;
+  };
+
+  template<> struct make_signed<unsigned char> {
+    typedef signed char type;
+  };
+
+  template<> struct make_signed<unsigned short> {
+    typedef short type;
+  };
+
+  template<> struct make_signed<unsigned int> {
+    typedef int type;
+  };
+
+  template<> struct make_signed<unsigned long> {
+    typedef long type;
+  };
+
+#if defined (BOOST_HAS_LONG_LONG)
+  template<> struct make_signed<unsigned long long> {
+    typedef long long type;
+  };
+#elif defined (BOOST_HAS_MS_INT64)
+  template<> struct make_signed<unsigned __int64> {
+    typedef __int64 type;
+  };
+#endif
+
+  namespace detail {
+    struct no_override { };
+
+    template<typename Base, typename Override>
+    struct maybe_override
+    {
+      // Probably need to disable this if there is no partial
+      // specialization support, because Override is almost certain to
+      // be an incomplete type. If that is right, the workaround
+      // version would just have to do "typedef Base type;"
+
+      typedef typename mpl::if_
+        <is_same <Override, no_override>, Base, Override>
+        ::type type;
+    };
+  }
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SUITE_UTILS_HPP
--- boost/python/suite/indexing/iterator_traits.hpp	(revision 6923)
+++ boost/python/suite/indexing/iterator_traits.hpp	(revision 6923)
@@ -0,0 +1,211 @@
+// -*- mode:c++ -*-
+//
+// Header file iterator_traits.hpp
+//
+// Traits information about iterators for use in determining what
+// Python methods to support for a container.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation as iterator_suite.hpp
+// 2003/ 9/12   rmg     Renamed iterator_traits.hpp
+//
+// $Id: iterator_traits.hpp,v 1.1.2.14 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ITERATOR_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_ITERATOR_TRAITS_HPP
+
+#include <boost/python/suite/indexing/suite_utils.hpp>
+#include <boost/python/suite/indexing/methods.hpp>
+//#include <boost/python/suite/indexing/workaround.hpp>
+
+//#include <boost/call_traits.hpp>
+//#include <boost/type_traits.hpp>
+#include <boost/iterator/iterator_traits.hpp>
+#include <boost/iterator/iterator_categories.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits common base class
+  //////////////////////////////////////////////////////////////////////////
+
+  template<typename Iterator>
+  struct base_iterator_traits
+  {
+  private:
+    typedef ::boost::detail::iterator_traits<Iterator> std_traits;
+    typedef typename std_traits::reference reference;
+
+  public:
+    //    typedef Iterator                             iterator;
+    //    typedef typename std_traits::value_type      value_type;
+    //    typedef typename std_traits::difference_type difference_type;
+
+    BOOST_STATIC_CONSTANT(
+        bool, has_mutable_ref = is_mutable_ref<reference>::value);
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for input iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template<typename Iterator>
+  struct input_iterator_traits : base_iterator_traits<Iterator>
+  {
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+            method_iter
+        ));
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for forward iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template<typename Iterator>
+  struct forward_iterator_traits
+    : public base_iterator_traits<Iterator>
+  {
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_len
+            | method_iter
+        ));
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for bidirectional iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template<typename Iterator>
+  struct bidirectional_iterator_traits
+    : public forward_iterator_traits<Iterator>
+  {
+    typedef forward_iterator_traits<Iterator> base_class;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              base_class::supported_methods
+
+            | detail::method_set_if<
+                  base_class::has_mutable_ref,
+                  method_reverse
+              >::value
+        ));
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for random access iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template<typename Iterator>
+  struct random_access_iterator_traits
+    : public bidirectional_iterator_traits<Iterator>
+  {
+    typedef bidirectional_iterator_traits<Iterator> base_class;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+            (base_class::supported_methods & ~method_iter)
+
+            | method_getitem
+            | method_getitem_slice
+
+            | detail::method_set_if<
+                  base_class::has_mutable_ref,
+                  method_setitem
+                | method_setitem_slice
+              >::value
+
+            | method_index     // Assumes value is equality_comparable
+            | method_contains  // Assumes value is equality_comparable
+            | method_count     // Assumes value is equality_comparable
+
+            | detail::method_set_if<
+                  base_class::has_mutable_ref,
+                  method_sort
+              >::value         // Assumes value is less_than_comparable
+
+        ));
+  };
+
+  namespace iterator_detail {
+    // Some meta-progamming machinery to select the right
+    // indexing::iterator_traits template on the basis of
+    // BOOST_ITERATOR_CATEGORY
+
+    typedef char basic_iter_sizer[1];
+    typedef char forward_iter_sizer[2];
+    typedef char bidirectional_iter_sizer[3];
+    typedef char random_access_iter_sizer[4];
+
+    basic_iter_sizer         &sizer (void *);
+    forward_iter_sizer       &sizer (std::forward_iterator_tag *);
+    bidirectional_iter_sizer &sizer (std::bidirectional_iterator_tag *);
+    random_access_iter_sizer &sizer (std::random_access_iterator_tag *);
+  
+    template<size_t Size> struct traits_by_size {
+      // Default implementation gives only the most basic support
+      template<typename Iterator>
+        struct traits {
+          typedef input_iterator_traits<Iterator> type;
+        };
+    };
+
+    template<>
+    struct traits_by_size<sizeof(forward_iter_sizer)> {
+      template<typename Iterator>
+        struct traits {
+          typedef forward_iterator_traits<Iterator> type;
+        };
+    };
+
+    template<>
+    struct traits_by_size<sizeof(bidirectional_iter_sizer)> {
+      template<typename Iterator>
+        struct traits {
+          typedef bidirectional_iterator_traits<Iterator> type;
+        };
+    };
+
+    template<>
+    struct traits_by_size<sizeof(random_access_iter_sizer)> {
+      template<typename Iterator>
+        struct traits {
+          typedef random_access_iterator_traits<Iterator> type;
+        };
+    };
+
+    template<typename Iterator>
+    class deduced_traits {
+      typedef typename ::boost::BOOST_ITERATOR_CATEGORY<Iterator>::type
+          category;
+
+      BOOST_STATIC_CONSTANT(
+          size_t, sizer_result = sizeof (sizer (new category)));
+
+    public:
+      typedef typename traits_by_size<sizer_result>
+        ::BOOST_NESTED_TEMPLATE traits<Iterator>::type type;
+    };
+  }
+
+  template<typename Iterator>
+  struct iterator_traits
+    : public iterator_detail::deduced_traits<Iterator>::type
+  {
+  };
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ITERATOR_TRAITS_HPP
--- boost/python/suite/indexing/element_proxy_traits.hpp	(revision 6923)
+++ boost/python/suite/indexing/element_proxy_traits.hpp	(revision 6923)
@@ -0,0 +1,89 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file element_proxy_traits.hpp
+//
+// Note: element_proxy.hpp must be included before this header
+//
+// This is a separate header so that element_proxy.hpp is not
+// dependant on register_ptr_to_python.hpp. This avoids a problem with
+// two-phase name lookup, where register_ptr_to_python must be
+// included *after* the element_proxy overload of boost::get_pointer
+// is declared.
+//
+// History
+// =======
+// 2003/10/23   rmg     File creation
+//
+// $Id: element_proxy_traits.hpp,v 1.1.2.5 2003/12/05 17:36:14 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ELEMENT_PROXY_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_ELEMENT_PROXY_TRAITS_HPP
+
+#include <boost/python/suite/indexing/element_proxy.hpp>
+#include <boost/python/suite/indexing/value_traits.hpp>
+#include <boost/python/register_ptr_to_python.hpp>
+#include <boost/python/implicit.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  template<typename ContainerProxy>
+  struct element_proxy_traits
+    : public value_traits<
+          BOOST_DEDUCED_TYPENAME ContainerProxy::raw_value_type>
+  {
+    typedef element_proxy<ContainerProxy> element_proxy_type;
+    typedef typename ContainerProxy::raw_value_type raw_value_type;
+    typedef value_traits<raw_value_type> base_type;
+
+    // Wrap the base class versions of the comparisons using
+    // indirection
+    struct less
+      : std::binary_function<element_proxy_type, element_proxy_type, bool>
+    {
+      typename base_type::less m_base_compare;
+
+      bool operator()(
+          element_proxy_type const &p1, element_proxy_type const &p2) const
+      {
+        return m_base_compare (*p1, *p2);
+      }
+    };
+
+    struct equal_to
+      : std::binary_function<raw_value_type, element_proxy_type, bool>
+    {
+      // First param is raw_value_type to interface smoothly with the
+      // bind1st used in default_algorithms::find
+
+      typename base_type::equal_to m_base_compare;
+
+      bool operator()(
+          raw_value_type const &v, element_proxy_type const &p) const
+      {
+        return m_base_compare (v, *p);
+      }
+    };
+
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class (PythonClass &, Policy const &)
+    {
+      register_ptr_to_python<element_proxy_type>();
+      implicitly_convertible<raw_value_type, element_proxy_type>();
+    }
+  };
+
+#if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  // value_traits partial specialization for element_proxy instances
+  template<typename ContainerProxy>
+  struct value_traits<element_proxy<ContainerProxy> >
+    : element_proxy_traits<ContainerProxy>
+  {
+  };
+#endif
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ELEMENT_PROXY_TRAITS_HPP
--- boost/python/suite/indexing/readme.txt	(revision 6923)
+++ boost/python/suite/indexing/readme.txt	(revision 6923)
@@ -0,0 +1,2 @@
+Installation tip: 
+    copy the content of this directory to ".../boost/python/suite/indexing" directory.
--- boost/python/suite/indexing/multimap.hpp	(revision 6923)
+++ boost/python/suite/indexing/multimap.hpp	(revision 6923)
@@ -0,0 +1,203 @@
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// Header file multimap.hpp
+//
+// Indexing algorithms support for std::multimap instances
+//
+// History
+// =======
+// 2006/10/27   Roman     File creation from map.hpp
+//
+
+#ifndef BOOST_PYTHON_INDEXING_MULTIMAP_HPP
+#define BOOST_PYTHON_INDEXING_MULTIMAP_HPP
+
+#include <boost/python/suite/indexing/container_traits.hpp>
+#include <boost/python/suite/indexing/container_suite.hpp>
+#include <boost/python/suite/indexing/algorithms.hpp>
+#include <boost/detail/workaround.hpp>
+#include <functional>
+#include <map>
+#include <boost/python/suite/indexing/pair.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::map instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename Container>
+  class multimap_traits : public base_container_traits<Container>
+  {
+    typedef base_container_traits<Container> base_class;
+
+  public:
+# if BOOST_WORKAROUND (BOOST_MSVC, <= 1200)
+    // MSVC6 has a nonstandard name for mapped_type in std::multimap
+    typedef typename Container::referent_type value_type;
+# else
+    typedef typename Container::mapped_type value_type;
+# endif
+    typedef value_type &                    reference;
+    typedef typename Container::key_type    index_type; // operator[]
+    typedef typename Container::key_type    key_type;   // find, count, ...
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <value_type>::param_type
+      value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <key_type>::param_type
+      key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS <index_type>::param_type
+      index_param;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_iter
+
+            | method_getitem
+            | method_contains
+            | method_count
+            | method_has_key
+
+            | detail::method_set_if<
+                  base_class::is_mutable,
+                    method_setitem
+                  | method_delitem
+                  | method_insert
+              >::value
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::multimap instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr = detail::no_override>
+  class multimap_algorithms
+    : public assoc_algorithms
+        <ContainerTraits,
+        typename detail::maybe_override
+            <multimap_algorithms<ContainerTraits, Ovr>, Ovr>
+          ::type>
+  {
+    typedef multimap_algorithms<ContainerTraits, Ovr> self_type;
+    typedef typename detail::maybe_override<self_type, Ovr>::type most_derived;
+    typedef assoc_algorithms<ContainerTraits, most_derived> Parent;
+
+  public:
+    typedef typename Parent::container container;
+    typedef typename Parent::reference reference;
+    typedef typename Parent::index_param index_param;
+    typedef typename Parent::value_param value_param;
+
+    static boost::python::list get (container &, index_param);
+    // Version to return only the mapped type
+
+    static boost::python::list keys( container & );
+  
+    static void      assign     (container &, index_param, value_param);
+    static void      insert     (container &, index_param, value_param);
+  
+    template<typename PythonClass, typename Policy>
+    static void visit_container_class( PythonClass &pyClass, Policy const &policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+      pyClass.def( "keys", &self_type::keys );        
+
+      typedef BOOST_DEDUCED_TYPENAME most_derived::container::value_type value_type;
+      mapping::register_value_type< PythonClass, value_type, Policy >( pyClass );
+      //now we can expose iterators functionality
+      pyClass.def( "__iter__", python::iterator< BOOST_DEDUCED_TYPENAME most_derived::container >() );
+        
+    }  
+
+  };
+
+  template<
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = multimap_traits<Container>
+  >
+  struct multimap_suite
+    : container_suite<Container, MethodMask, multimap_algorithms<Traits> >
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (multimap version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  boost::python::list
+  multimap_algorithms<ContainerTraits, Ovr>::get (container &c, index_param ix)
+  {
+    boost::python::list l;
+    typedef BOOST_DEDUCED_TYPENAME container::iterator iter_type;
+    for( iter_type index = c.lower_bound( ix ); index != c.upper_bound( ix ); ++index ){
+        boost::python::object v( index->second );
+        l.append( v );
+    }
+    return l;
+  }
+
+  template<typename ContainerTraits, typename Ovr>
+  boost::python::list
+  multimap_algorithms<ContainerTraits, Ovr>::keys( container &c )
+  {
+    boost::python::list _keys;
+    //For some reason code with set could not be compiled
+    //std::set< key_param > unique_keys;
+    typedef BOOST_DEDUCED_TYPENAME container::iterator iter_type;
+    for( iter_type index = most_derived::begin(c); index != most_derived::end(c); ++index ){
+        //if( unique_keys.end() == unique_keys.find( index->first ) ){
+        //    unique_keys.insert( index->first );
+        if( !_keys.count( index->first ) ){
+            _keys.append( index->first );
+        }
+        //}
+    }
+        
+    return _keys;
+  }
+  
+  
+  /////////////////////////////////////////////////////////////////////////
+  // Assign a value at a particular index (map version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  multimap_algorithms<ContainerTraits, Ovr>::assign(
+      container &c, index_param ix, value_param val)
+  {
+    typedef std::pair<
+        BOOST_DEDUCED_TYPENAME self_type::container_traits::index_type
+        , BOOST_DEDUCED_TYPENAME self_type::container_traits::value_type>
+    pair_type;
+
+    // Can't use std::make_pair, because param types may be references
+    c.insert (pair_type (ix, val));
+  }
+
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert a new key, value pair into a map
+  /////////////////////////////////////////////////////////////////////////
+
+  template<typename ContainerTraits, typename Ovr>
+  void
+  multimap_algorithms<ContainerTraits, Ovr>::insert(
+      container &c, index_param ix, value_param val)
+  {
+    typedef std::pair
+      <BOOST_DEDUCED_TYPENAME self_type::container_traits::index_type,
+      BOOST_DEDUCED_TYPENAME self_type::container_traits::value_type>
+      pair_type;
+
+    // Can't use std::make_pair, because param types may be references
+    c.insert (pair_type (ix, val) );
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_MULTIMAP_HPP
--- boost/python/suite/indexing/shared_proxy_impl.hpp	(revision 6923)
+++ boost/python/suite/indexing/shared_proxy_impl.hpp	(revision 6923)
@@ -0,0 +1,105 @@
+//
+// Header file shared_proxy_impl.hpp
+//
+// The shared implementation of the element proxy (const and non-const
+// versions).  Multiple proxy pointers can refer to the same shared
+// implementation, meaning that only one object requires updating to
+// affect all proxy pointers that ultimately refer to the same index
+// in the container.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 8/29   rmg     File creation from container_proxy.hh
+//
+// $Id: shared_proxy_impl.hpp,v 1.1.2.8 2003/11/24 14:28:31 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SHARED_PROXY_IMPL_HPP
+#define BOOST_PYTHON_INDEXING_SHARED_PROXY_IMPL_HPP
+
+#include <memory>
+#include <boost/python/suite/indexing/workaround.hpp>
+
+namespace boost { namespace python { namespace indexing {
+  template<class ContainerProxy>
+  class shared_proxy_impl
+  {
+  public:
+    typedef typename ContainerProxy::raw_value_type value_type;
+    typedef value_type &reference;
+    typedef value_type *pointer;
+    typedef void iterator_category;  // Fudge for boost::indirect_iterator
+    typedef void difference_type;    // Fudge for boost::indirect_iterator
+
+    reference operator*() const;
+    pointer operator->() const { return &(**this); }
+
+    ContainerProxy *owner() const { return m_owner_ptr; }
+    size_t index() const { return m_index; }
+
+    shared_proxy_impl (value_type const &copy);
+    // Creates value-only (detached) proxy
+
+#if defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+  public:
+#else
+  private:
+    template<class C, class A, class G> friend class container_proxy;
+#endif
+
+    shared_proxy_impl (ContainerProxy *, size_t);
+    void detach ();
+
+    ContainerProxy *m_owner_ptr;             // When attached
+    size_t m_index;                          // When attached
+    std::auto_ptr<value_type> m_element_ptr; // When detached
+
+  private:
+    // Not implemented
+    shared_proxy_impl (shared_proxy_impl const &);
+    shared_proxy_impl &operator= (shared_proxy_impl const &);
+  };
+
+  template<class ContainerProxy>
+  shared_proxy_impl<ContainerProxy>::shared_proxy_impl (ContainerProxy *owner,
+                                                        size_t index)
+    : m_owner_ptr (owner),
+    m_index (index),
+    m_element_ptr ()
+  {
+  }
+
+  template<class ContainerProxy>
+  shared_proxy_impl<ContainerProxy>::shared_proxy_impl (value_type const &val)
+    : m_owner_ptr (0),
+    m_index (static_cast<size_t>(-1)),
+    m_element_ptr (new value_type (val))
+  {
+  }
+
+  template<class ContainerProxy>
+  typename shared_proxy_impl<ContainerProxy>::reference
+  shared_proxy_impl<ContainerProxy>::operator* () const
+  {
+    return m_owner_ptr
+      ? m_owner_ptr->raw_container().BOOST_PYTHON_INDEXING_AT (m_index)
+      : *m_element_ptr;
+  }
+
+  template<class ContainerProxy>
+  void shared_proxy_impl<ContainerProxy>::detach ()
+  {
+    BOOST_PYTHON_INDEXING_RESET_AUTO_PTR(
+        m_element_ptr, new value_type (**this));
+    m_owner_ptr = 0;
+    m_index = static_cast<size_t>(-1);
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SHARED_PROXY_IMPL_HPP
--- libs/python/build/Jamfile.v2	(revision 6850)
+++ libs/python/build/Jamfile.v2	(revision 6923)
@@ -107,4 +107,6 @@
         exec.cpp
         object/function_doc_signature.cpp
+        indexing/indexing_slice.cpp
+        indexing/python_iterator.cpp
         :   # requirements
             <link>static:<define>BOOST_PYTHON_STATIC_LIB 
--- libs/python/src/indexing/indexing_slice.cpp	(revision 6923)
+++ libs/python/src/indexing/indexing_slice.cpp	(revision 6923)
@@ -0,0 +1,76 @@
+// Module slice.cpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: slice.cpp,v 1.1.2.7 2003/11/24 14:28:32 raoulgough Exp $
+//
+
+#include <boost/python/suite/indexing/slice.hpp>
+#include <algorithm>
+
+/////////////////////////////////////////////////////////////////////////////
+// MSVC6 workarounds
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined (BOOST_NO_MEMBER_TEMPLATES)
+namespace boost { namespace python { namespace indexing {
+  slice::slice (::boost::python::handle<> const &p) : object (p) { }
+  slice::slice (::boost::python::detail::borrowed_reference p) : object (p) { }
+  slice::slice (::boost::python::detail::new_reference p) : object (p) { }
+  slice::slice (::boost::python::detail::new_non_null_reference p) : object (p) { }
+} } }
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// slice copy constructor
+/////////////////////////////////////////////////////////////////////////////
+
+boost::python::indexing::slice::slice (slice const &copy)
+  : object (copy)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// integer_slice constructor
+/////////////////////////////////////////////////////////////////////////////
+
+boost::python::indexing::integer_slice
+::integer_slice (slice const &sl, index_type length)
+  : m_slice (sl)
+  // Leave index members uninitialized
+{
+  PySlice_GetIndices(
+      reinterpret_cast<PySliceObject *> (m_slice.ptr()),
+      length,
+      &m_start,
+      &m_stop,
+      &m_step);
+
+  if (m_step == 0)
+    {
+      // Can happen with Python prior to 2.3
+      PyErr_SetString (PyExc_ValueError, "slice step cannot be zero");
+      boost::python::throw_error_already_set ();
+    }
+
+  m_start = std::max (static_cast<index_type> (0), std::min (length, m_start));
+  m_stop = std::max (static_cast<index_type> (0), std::min (length, m_stop));
+  m_direction = (m_step > 0) ? 1 : -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Check if an index is within the range of this integer_slice
+/////////////////////////////////////////////////////////////////////////////
+
+bool boost::python::indexing::integer_slice::in_range (index_type index)
+{
+  return ((m_stop - index) * m_direction) > 0;
+}
--- libs/python/src/indexing/python_iterator.cpp	(revision 6923)
+++ libs/python/src/indexing/python_iterator.cpp	(revision 6923)
@@ -0,0 +1,74 @@
+// -*- mode:c++ -*-
+//
+// Module python_iterator.cpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at http://www.boost.org/LICENSE_1_0.txt)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: python_iterator.cpp,v 1.1.2.5 2003/11/24 16:35:19 raoulgough Exp $
+//
+
+#include <boost/python/suite/indexing/python_iterator.hpp>
+#include <boost/python/handle.hpp>
+
+////////////////////////////////////////////////////////////////////////////
+// python_iterator constructor
+///////////////////////////////////////////////////////////////////////////
+
+boost::python::indexing::python_iterator
+::python_iterator (boost::python::object obj)
+  : m_iter_obj (handle<> (PyObject_GetIter (obj.ptr()))),
+    m_next_method (m_iter_obj.attr ("next")),
+    m_current()
+{
+}
+
+////////////////////////////////////////////////////////////////////////////
+// Get our next item (if any)
+///////////////////////////////////////////////////////////////////////////
+
+bool boost::python::indexing::python_iterator::next ()
+{
+  bool result = true; // Assume success
+
+  try
+    {
+      m_current = m_next_method ();
+    }
+
+  catch (boost::python::error_already_set const &)
+    {
+      if (PyErr_ExceptionMatches (PyExc_StopIteration))
+        {
+          // Eat this exception
+          PyErr_Clear ();
+          m_current = boost::python::object (); // No current object
+          result = false; // Report failure via return value only
+        }
+
+      else
+        {
+          // Pass it up the line
+          throw;
+        }
+    }
+
+  return result;
+}
+
+////////////////////////////////////////////////////////////////////////////
+// Return our current item
+///////////////////////////////////////////////////////////////////////////
+
+boost::python::object
+boost::python::indexing::python_iterator::current () const
+{
+  return m_current;
+}
